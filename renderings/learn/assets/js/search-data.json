{"0": {
    "doc": "Best Practices",
    "title": "Best Practices",
    "content": "This page contains general pieces of advice which do not strictly belong to the Specification Explained chapter because they are not directly tied to the OpenAPI Specification. However, they greatly simplify creating and maintaining OpenAPI documents, so they are worth keeping in mind. ",
    "url": "/best-practices.html",
    
    "relUrl": "/best-practices.html"
  },"1": {
    "doc": "Best Practices",
    "title": "Use a Design-First Approach",
    "content": "Traditionally, two main approaches exist when creating OpenAPI documents: Code-first and Design-first. | In the Code-first approach, the API is first implemented in code, and then its description is created from it, using code comments, code annotations or simply written from scratch. This approach does not require developers to learn another language so it is usually regarded as the easiest one. | Conversely, in Design-first, the API description is written first and then the code follows. The first obvious advantages are that the code already has a skeleton upon which to build, and that some tools can provide boilerplate code automatically. | . There have been a number of heated debates over the relative merits of these two approaches but, in the opinion of the OpenAPI Initiative, the importance of using Design-first cannot be stressed strongly enough. The reason is simple: The number of APIs that can be created in code is far superior to what can be described in OpenAPI. To emphasize: OpenAPI is not capable of describing every possible HTTP API, it has limitations. Therefore, unless these descriptive limitations are perfectly known and taken into account when coding the API, they will rear their ugly head later on when trying to create an OpenAPI description for it. At that point, the right fix will be to change the code so that it uses an API which can be actually described with OpenAPI (or switch to Design-first altogether). Sometimes, however, since it is late in the process, it will be preferred to twist the API description so that it matches more or less the actual API. It goes without saying that this leads to unintuitive and incomplete descriptions, that will rarely scale in the future. Finally, there exist a number of validation tools that can verify that the implemented code adheres to the OpenAPI description. Running these tools as part of a Continuous Integration process allows changing the OpenAPI document with peace of mind, since deviations in the code behavior will be promptly detected. Bottom line: OpenAPI opens the door to a wealth of automated tools. Make sure you use them! . ",
    "url": "/best-practices.html#use-a-design-first-approach",
    
    "relUrl": "/best-practices.html#use-a-design-first-approach"
  },"2": {
    "doc": "Best Practices",
    "title": "Keep a Single Source of Truth",
    "content": "Regardless of your design approach (design-first or code-first) always keep a single source of truth, i.e., information should not be duplicated in different places. It is really the same concept used in programming, where repeated code should be moved to a common function. Otherwise, eventually one of the places will be updated while the other won’t, leading to headaches… in the best of cases. For instance, it is also commonplace to use code annotations to generate an OpenAPI description and then commit the latter to source control while the former still lingers in the code. As a result, newcomers to the project will not know which one is actually in use and mistakes will be made. Alternatively, you can use a Continuous Integration test to ensure that the two sources stay consistent. ",
    "url": "/best-practices.html#keep-a-single-source-of-truth",
    
    "relUrl": "/best-practices.html#keep-a-single-source-of-truth"
  },"3": {
    "doc": "Best Practices",
    "title": "Add OpenAPI Documents to Source Control",
    "content": "OpenAPI descriptions are not just a documentation artifact: they are first-class source files which can drive a great number of automated processes, including boilerplate generation, unit testing and documentation rendering. As such, OpenAPI description should be committed to source control, and, in fact, they should be among the first files to be committed. From there, they should also participate in Continuous Integration processes. ",
    "url": "/best-practices.html#add-openapi-documents-to-source-control",
    
    "relUrl": "/best-practices.html#add-openapi-documents-to-source-control"
  },"4": {
    "doc": "Best Practices",
    "title": "Make the OpenAPI Documents Available to the Users",
    "content": "Beautifully-rendered documents can be very useful for the users of an API, but sometimes they might want to access the source OpenAPI description. For instance, to use tools to generate client code for them, or to build automated bindings for some language. Therefore, making the OpenAPI documents available to the users is an added bonus for them. The document can even be made available through the same API to allow runtime discovery. ",
    "url": "/best-practices.html#make-the-openapi-documents-available-to-the-users",
    
    "relUrl": "/best-practices.html#make-the-openapi-documents-available-to-the-users"
  },"5": {
    "doc": "Best Practices",
    "title": "There is Seldom Need to Write OpenAPI Documents by Hand",
    "content": "Since OpenAPI documents are plain text files, in an easy-to-read format (be it JSON or YAML), API designers are usually tempted to write them by hand. While there is nothing stopping you from doing this, and, in fact, hand-written API descriptions are usually the most terse and efficient, approaching any big project by such method is highly impractical. Instead, you should try the other existing creation methods and choose the one that better suits you and your team (No YAML or JSON knowledge needed!): . | OpenAPI Editors: Be it text editors or GUI editors they usually take care of repetitive tasks, allow you to keep a library of reusable components and provide real-time preview of the generated documentation. | Domain-Specific Languages: As its name indicates, DSL’s are API description languages tailored to specific development fields. A tool is then used to produce the OpenAPI document. A new language has to be learned, but, in return, extremely concise descriptions can be achieved. | Code Annotations: Most programming languages allow you to annotate the code, be it with specific syntax or with general code comments. These annotations, for example, can be used to extend a method signature with information regarding the API endpoint and HTTP method that lead to it. A tool can then parse the code annotations and generate OpenAPI documents automatically. This method fits very nicely with the code-first approach, so keep in mind the first advice given at the top of this page when using it (Use a Design-First Approach)… . | A Mix of All the Above: It’s perfectly possible to create the bulk of an OpenAPI document using an editor or DSL and then hand-tune the resulting file. Just be aware of the second advice above (Keep a Single Source of Truth): Once you modify a file it becomes the source of truth and the previous one should be discarded (maybe keep it as backup, but out of the sight and reach of children and newcomers to the project). | . ",
    "url": "/best-practices.html#there-is-seldom-need-to-write-openapi-documents-by-hand",
    
    "relUrl": "/best-practices.html#there-is-seldom-need-to-write-openapi-documents-by-hand"
  },"6": {
    "doc": "Best Practices",
    "title": "Working with Big Documents",
    "content": "This is a collection of small hints related to working with large API description documents. | Do not repeat yourself (The DRY principle). If the same piece of YAML or JSON appears more than once in the document, it’s time to move it to the components section and reference it from other places using $ref (See Reusing Descriptions. Not only will the resulting document be smaller but it will also be much easier to maintain). Components can be referenced from other files, so you can even reuse them across different API documents! . | Split the document into several files: Smaller files are easier to navigate, but too many of them are equally taxing. The key lies somewhere in the middle. A good rule of thumb is to use the natural hierarchy present in URLs to build your file structure. For example, put all routes starting with /users (like /users and /users/{id}) in the same file (think of it as a “sub-API”). Bear in mind that some tools might have issues with large files, whereas some other tools might not handle too many files gracefully. The solution will have to take your toolkit into account. | Use tags to keep things organized: Tags have not been described in the Specification chapter, but they can help you arrange your operations and find them faster. A tag is simply a piece of metadata (a unique name and an optional description) that you can attach to operations. Tools, specially GUI editors, can then sort all your API’s operation by their tags to help you keep them organized. | . ",
    "url": "/best-practices.html#working-with-big-documents",
    
    "relUrl": "/best-practices.html#working-with-big-documents"
  },"7": {
    "doc": "Best Practices",
    "title": "Links to External Best Practices",
    "content": "There’s quite a bit of literature about how to organize your API more efficiently. Make sure you check out how other people solved the same issues you are facing now! . For example: . | The API Stylebook contains internal API Design Guidelines shared with the community by some well known companies and government agencies. | . ",
    "url": "/best-practices.html#links-to-external-best-practices",
    
    "relUrl": "/best-practices.html#links-to-external-best-practices"
  },"8": {
    "doc": "Reusing Description",
    "title": "Reusing Descriptions",
    "content": "As is often the case, the example built through the previous pages has grown too large to be easily manageable. This page introduces a mechanism to remove redundancy from an OpenAPI document by reusing portions of it. ",
    "url": "/specification/components.html#reusing-descriptions",
    
    "relUrl": "/specification/components.html#reusing-descriptions"
  },"9": {
    "doc": "Reusing Description",
    "title": "The Components Object",
    "content": "The Components Object, accessible through the components field in the root OpenAPI Object, contains definitions for objects to be reused in other parts of the document. The OpenAPI Object is explained in the Structure of an OpenAPI Document page.The Schema Object is explained in the Content of Message Bodies page.The Response Object is explained in the API Endpoints page.The Parameter Object is explained in the Parameters and Payload of an Operation page. Most objects in an OpenAPI document can be replaced by a reference to a component, drastically reducing the document’s size and maintenance cost (just like methods do in programming languages). Not all objects can be referenced, though, only those listed as fields of the Components Object like schemas, responses and parameters to name a few. Each field in the Components Object is a map pairing component names with objects to be reused. The type of these objects must match the parent field, e.g. objects in the schemas map must be Schema Objects. components: schemas: coordinate: type: integer minimum: 1 maximum: 3 parameters: rowParam: name: row in: path required: true . The above example defines two components: . | coordinate is a schema component, usable wherever a Schema Object is expected. | rowParam is a parameter component, usable wherever a Parameter Object is expected. | . The next section explains how to reference these components. ",
    "url": "/specification/components.html#the-components-object",
    
    "relUrl": "/specification/components.html#the-components-object"
  },"10": {
    "doc": "Reusing Description",
    "title": "The Reference Object",
    "content": "Any OpenAPI object of the types supported by the Components Object can be replaced by a Reference Object pointing to a component. Reference Objects are actually JSON References: they contain a single field named $ref and its string value is a URI pointing to the referenced object: . $ref: 'https://gigantic-server.com/schemas/Monster/schema.yaml' . References can be absolute or relative, and they can include a fragment identifier . $ref: './another_file.yaml#rowParam' . To complete the example from the previous section: . components: schemas: coordinate: type: integer minimum: 1 maximum: 3 parameters: rowParam: name: row in: path required: true schema: $ref: \"#/components/schemas/coordinate\" columnParam: name: column in: path required: true schema: $ref: \"#/components/schemas/coordinate\" paths: /board/{row}/{column}: parameters: - $ref: \"#/components/parameters/rowParam\" - $ref: \"#/components/parameters/columnParam\" . Note how all references point to different fragments inside the same document (the one being processed). Note also how the coordinate schema is used twice (in the rowParam and columnParam parameters), and how these two parameters are referenced from the /board/{row}/{column} path. ",
    "url": "/specification/components.html#the-reference-object",
    
    "relUrl": "/specification/components.html#the-reference-object"
  },"11": {
    "doc": "Reusing Description",
    "title": "Tic Tac Toe Example",
    "content": "The complete Tic Tac Toe sample API (not included here for brevity) makes heavy use of components. Note for example how different endpoints return a #/components/schemas/status on success, or a #/components/schemas/errorMessage on error. ",
    "url": "/specification/components.html#tic-tac-toe-example",
    
    "relUrl": "/specification/components.html#tic-tac-toe-example"
  },"12": {
    "doc": "Reusing Description",
    "title": "Summary",
    "content": "Whenever the same piece of JSON or YAML is repeated in an OpenAPI document, it is probably worth converting it into a component and referencing it everywhere else. Furthermore, Reference Objects allow splitting a document into several files to keep them organized and their individual size manageable. This page has shown that: . | Reusable Components Objects can be defined by using the components field of the root OpenAPI Object. | Components can be referenced from any place where an object of the same type is expected using $ref. | References are actually URIs so they are very flexible. | . The next page explains how to include documentation and examples in an OpenAPI document. ",
    "url": "/specification/components.html#summary",
    
    "relUrl": "/specification/components.html#summary"
  },"13": {
    "doc": "Reusing Description",
    "title": "Reusing Description",
    "content": " ",
    "url": "/specification/components.html",
    
    "relUrl": "/specification/components.html"
  },"14": {
    "doc": "Content of Message Bodies",
    "title": "Content of Message Bodies",
    "content": "The previous page showed how to define API endpoints but it didn’t explain how to describe the content of the responses through the content field. This page clarifies this important field, which can also be used to describe queries, as shown in the Parameters page. ",
    "url": "/specification/content.html",
    
    "relUrl": "/specification/content.html"
  },"15": {
    "doc": "Content of Message Bodies",
    "title": "The content Field",
    "content": "This field can be found both in Response Objects and Request Body Objects. It is a map pairing standard RFC6838 Media Types with OpenAPI Media Type Objects. The Response Object is explained in the API Endpoints page.The Request Body Object is explained in the Parameters and Payload of an Operation page. This allows returning content (or accepting content) in different formats, each one with a different structure described by the Media Type Object. Wildcards are accepted for the media types, with the more specific ones taking precedence over the generic ones. content: application/json: ... text/html: ... text/*: ... ",
    "url": "/specification/content.html#the-content-field",
    
    "relUrl": "/specification/content.html#the-content-field"
  },"16": {
    "doc": "Content of Message Bodies",
    "title": "The Media Type Object",
    "content": "The Media Type Object describes the structure of the content and provides examples for documentation and mocking purposes (examples are dealt with in the Documentation page). The structure is described in the schema field explained next. content: application/json: schema: ... ",
    "url": "/specification/content.html#the-media-type-object",
    
    "relUrl": "/specification/content.html#the-media-type-object"
  },"17": {
    "doc": "Content of Message Bodies",
    "title": "The Schema Object",
    "content": "The Schema Object defines a data type which can be a primitive (integer, string, …), an array or an object depending on its type field. type is a string and its possible values are: number, string, boolean, array and object. Depending on the selected type a number of other fields are available to further specify the data format. For example, for string types the length of the string can be limited with minLength and maxLength. Similarly, integer types, accept minimum and maximum values. No matter the type, if the amount of options for the data is limited to a certain set, it can be specified with the enum array. All these properties are listed in the Schema Object specification. Example integer with limited range: . content: application/json: schema: type: integer minimum: 1 maximum: 100 . Example string with only three valid options: . content: application/json: schema: type: string enum: - Alice - Bob - Carl . Array types should have an items field, which is a Schema Object itself, and defines the type for each element of the array. Additionally, the size of the array can be limited with minItems and maxItems. content: application/json: schema: type: array minItems: 1 maxItems: 10 items: type: integer . Finally, object types should have a properties field listing the properties of the object. This field is a map pairing property names with a Schema Object defining their type. This allows building data types as complex as required. Here’s an example defining an object with two fields: a productName string and a productPrice number: . content: application/json: schema: type: object properties: productName: type: string productPrice: type: number . ",
    "url": "/specification/content.html#the-schema-object",
    
    "relUrl": "/specification/content.html#the-schema-object"
  },"18": {
    "doc": "Content of Message Bodies",
    "title": "Tic Tac Toe Example",
    "content": "The Tic Tac Toe sample API given so far has one endpoint with one unspecified response. The snippet below adds the description of this content: . openapi: 3.1.0 info: title: Tic Tac Toe description: | This API allows writing down marks on a Tic Tac Toe board and requesting the state of the board or of individual squares. version: 1.0.0 paths: # Whole board operations /board: get: summary: Get the whole board description: Retrieves the current state of the board and the winner. responses: \"200\": description: \"OK\" content: application/json: schema: type: object properties: winner: type: string enum: [\".\", \"X\", \"O\"] description: | Winner of the game. `.` means nobody has won yet. board: type: array maxItems: 3 minItems: 3 items: type: array maxItems: 3 minItems: 3 items: type: string enum: [\".\", \"X\", \"O\"] description: | Possible values for a board square. `.` means empty square... The response contains an object is JSON format with two fields: . | winner is a string with only three possible values: ., X and O. | board is a 3-element array where each item is another 3-element array, effectively building a 3x3 square matrix. Each element in the matrix is a string with only three possible values: ., X and O. | . This document is starting to grow too big and complex. The Reusing Descriptions page explains how to name sections of an OpenAPI document in order to reuse them (like the strings with three options above, which appear twice). ",
    "url": "/specification/content.html#tic-tac-toe-example",
    
    "relUrl": "/specification/content.html#tic-tac-toe-example"
  },"19": {
    "doc": "Content of Message Bodies",
    "title": "Summary",
    "content": "This page has shown how to describe the content of the body of a response or query. More precisely: . | The content field maps Media Types to Media Type Objects. | Each Media Type Object has a schema field describing a Schema Object. | Schema Objects define a data type which can be customized through multiple properties like minimum, maximum, items, properties and many more. | . The next page explains how to define the parameters that an endpoint accepts. ",
    "url": "/specification/content.html#summary",
    
    "relUrl": "/specification/content.html#summary"
  },"20": {
    "doc": "Definitions",
    "title": "Definitions",
    "content": ". | document: A local file, network resource, or other distinct entity in a particular format such as JSON or YAML | entry document: The document in an OAD where processing begins, starting with an OpenAPI Object (3.0, 3.1) | OpenAPI Description (OAD): One or more documents written according to a specific version of the OpenAPI Specification, that together describe an API | OpenAPI Initiative (OAI): The standards body responsible for the development of the OpenAPI Specification (not to be confused with the unrelated and more recent “OpenAI”) | OpenAPI Specification (OAS): The formal requirements for the OpenAPI format, which exists in several versions (e.g. 3.0.3, 3.1.0) | reference: A connection from one location in an OAD to another in which the reference target is identified by a URI; the \"$ref\" and \"operationRef\" keywords implement references in the OAS | reference removal: The process of replacing references with their targets; not all references can be removed | reference resolution: The process of associating all reference sources with their targets, typically in-memory, without needing to remove references; all references in a well-formed OAD are resolvable | Uniform Resource Identifier (URI): An identifier for a resource of any kind, which may or may not indicate its location | Uniform Resource Locator (URL): A URI intended to be used as a locator for retrieving or otherwise interacting with a resource | URI-reference resolution: The process of resolving a URI-reference against a base URI to produce a full URI (which must include a scheme); this must be done with the values of \"$ref\" and similar keywords before as the first step of reference resolution (or reference removal) | . ",
    "url": "/definitions.html",
    
    "relUrl": "/definitions.html"
  },"21": {
    "doc": "Definitions",
    "title": "A note on the history of “document”, “definition”, and “description”",
    "content": "Up through OAS 3.0.3 and 3.1.0, the OAS contained a section titled “OpenAPI Document”, with differing definintions depending the OAS version. The terms “OpenAPI Definition”, “OpenAPI Description”, and other variations and combinations were also used within the specification and/or the learn.openapips.org site. In September 2023, the OAI Technical Steering Committee (TSC) agreed to standardize on “OpenAPI Description” for the complete logical entity that descrribes an API, and to reserve the term “document” (lower-cased) for its common meaning. Resolving the debate between “OpenAPI Description” and “OpenAPI Definition” hinged on the observation that while “definition” is appropriate when the API code is generated from the OAD, it is not accurate when an OAD is written for an existing API. The term “description” is accurate in both cases. ",
    "url": "/definitions.html#a-note-on-the-history-of-document-definition-and-description",
    
    "relUrl": "/definitions.html#a-note-on-the-history-of-document-definition-and-description"
  },"22": {
    "doc": "Definitions",
    "title": "Documents and OpenAPI Descriptions",
    "content": "An OpenAPI Description, or OAD, can be structured as one or more documents. Those documents are typically stored as local files with .json or .yaml (or .yml) extensions, or as HTTP-accessible network resources of type application/openapi+json or application/openapi+yaml. The documents are connected by references, as described in the Using References In OpenAPI Descriptions guide. ",
    "url": "/definitions.html#documents-and-openapi-descriptions",
    
    "relUrl": "/definitions.html#documents-and-openapi-descriptions"
  },"23": {
    "doc": "Providing Documentation and Examples",
    "title": "Providing Documentation and Examples",
    "content": "Besides machine-readable descriptions, an OpenAPI document can also include traditional documentation meant to be read by developers. Automatic documentation generators can then merge both and produce comprehensive, nicely-structured reference guides, for example. This page shows how to take full advantage of special documentation capabilities in OpenAPI like markdown syntax or example objects. ",
    "url": "/specification/docs.html",
    
    "relUrl": "/specification/docs.html"
  },"24": {
    "doc": "Providing Documentation and Examples",
    "title": "The Documentation Fields",
    "content": "Almost every object in the OpenAPI Specification accepts a description field which can provide additional information for developers, beyond what can be automatically generated from the API descriptions. For instance, a parameter’s name, type and valid range of values are already present in the API definition. The description field can complement this information by explaining the purpose of this parameter, the effect of each value or possible interactions with other parameters: . paths: /audio/volume: put: requestBody: required: true content: application/json: schema: type: integer minimum: 0 maximum: 11 description: Current volume for all audio output. 0 means no audio output (mute). 10 is the maximum value. 11 enables the overdrive system (danger!). When set to 0 all other audio settings have no effect... Additionally, the Path Item, Operation and Example objects, which usually have long descriptions, accept a summary field providing a short description. Documentation generators can use this field in the full list of paths, or in page headers, for example. ",
    "url": "/specification/docs.html#the-documentation-fields",
    
    "relUrl": "/specification/docs.html#the-documentation-fields"
  },"25": {
    "doc": "Providing Documentation and Examples",
    "title": "Providing Long Descriptions in YAML",
    "content": "In JSON format all strings are enclosed in quotes and it is therefore clear where they begin and end. In YAML, though, strings more than one line long can be a bit confusing. To begin with, long descriptions like the one above end when a YAML line is found with smaller indentation. Leading space is important! . Furthermore, the above example uses the plain mode for strings. It is easy to use because it does not require any special syntax, but it can confuse YAML-parsing tools if the string contains colon : or hash # characters. In these cases, the whole string must be enclosed in single or double quotes: . description: \"Beware of lines containing colons and hashes like this: #\" . If precise control over the location of line breaks is required, two more string modes exist, enabled by an indicator character alone on the first line of the description: . | Literal mode (Pipe | indicator character): Line breaks in the source YAML file are preserved in the output. | Folded mode (Greater-than sign &gt; indicator character): Line breaks are removed so the output is a single string. Use an empty line to force a line break. | . YAML source - Literal mode . description: | This is a string in multiple lines. And an extra one. Output - Literal mode . This is a string in multiple lines. And an extra one. YAML source - Folded mode . description: &gt; This is a string in multiple lines. And an extra one. Output - Folded mode . This is a string in multiple lines. And an extra one. The literal and folded modes do not need to use quotes. ",
    "url": "/specification/docs.html#providing-long-descriptions-in-yaml",
    
    "relUrl": "/specification/docs.html#providing-long-descriptions-in-yaml"
  },"26": {
    "doc": "Providing Documentation and Examples",
    "title": "The CommonMark Syntax",
    "content": "description fields allow rich text formatting by using CommonMark 0.27. This section is a quick summary of the syntax of the most commonly used features. Far more features than listed below are available (including HTML tags), but given that OpenAPI descriptions are meant to be included inside larger auto-generated documentation, using more advanced formatting is typically very complicated. Headings . # Level 1 ## Level 2 ### Level 3 . Emphasis . *Emphasis* **Strong Emphasis** ***Both*** . Lists . - Item 1 - Item 2 - Item 2.1 . Code . An inline `code span`. ``` A fenced code block ``` . Links . [Link text](Link URL) ![Alt text](Image URL) . ",
    "url": "/specification/docs.html#the-commonmark-syntax",
    
    "relUrl": "/specification/docs.html#the-commonmark-syntax"
  },"27": {
    "doc": "Providing Documentation and Examples",
    "title": "The Example Object",
    "content": "Finally, some OpenAPI objects can list examples explicitly instead of having them embedded in the description field, enabling automated processing by tools. This allows, among other things: . | Special rendering of the examples inside the documentation. | Example objects can be used by mock servers as return values. | . Two different fields provide this functionality: example allows one sample whereas examples allows multiple. Only one of the two fields can be present in each object. The content of the example field (found in Parameter, Media Type and Schema Objects) must match the format of its parent object: . schema: coordinate: type: integer minimum: 1 maximum: 3 example: 1 . On the other hand, the examples field (found in Parameter and Media Type Objects) is a map pairing an example name with an Example Object. This object provides a summary and a description for the example along with the actual code (inside the value field or as an external reference in the externalValue field, but not both). This is a snippet from the Tic Tac Toe sample API: . responses: \"400\": description: The provided parameters are incorrect content: text/html: # This is a Media Type Object schema: type: string examples: illegalCoordinates: value: \"Illegal coordinates.\" notEmpty: value: \"Square is not empty.\" invalidMark: value: \"Invalid Mark (X or O).\" . Note how all examples match the schema provided (they are all strings). ",
    "url": "/specification/docs.html#the-example-object",
    
    "relUrl": "/specification/docs.html#the-example-object"
  },"28": {
    "doc": "Providing Documentation and Examples",
    "title": "Summary",
    "content": "This page has shown the features provided by OpenAPI to aid in the documentation process. More specifically: . | Documentation can be added almost everywhere using a description field. Some objects also allow a summary. | Text can use rich formatting using CommonMark syntax, quickly summarized in this page. | Documentation can be extended with sample code using the example or examples fields. | . The next page shows how to specify the server where the API can be accessed. ",
    "url": "/specification/docs.html#summary",
    
    "relUrl": "/specification/docs.html#summary"
  },"29": {
    "doc": "Referencing FAQ",
    "title": "Referencing FAQ",
    "content": " ",
    "url": "/referencing/faq.html",
    
    "relUrl": "/referencing/faq.html"
  },"30": {
    "doc": "Referencing FAQ",
    "title": "Do I need to read the entire referencing guide?",
    "content": "If your OpenAPI Description (OAD): . | consists only of a single JSON or YAML document | contains only references that are fragments (beginning with a \"#\", e.g. {\"$ref\": \"#/components/responses/oops\"}) | does not have any other keywords in the same object as any \"$ref\" | (OAS 3.1 only) does not use \"$id\"if you are using OAS 3.1, you are not using the \"$id\" keyword Schema Objects | (OAS 3.1 only) does not use \"$dynamicRef\" or \"$dynamicAnchor\" | . Then your use of references is simple enough that your references will do what you expect with any tool that supports them at all. You probably do not need to read the rest of this page. ",
    "url": "/referencing/faq.html#do-i-need-to-read-the-entire-referencing-guide",
    
    "relUrl": "/referencing/faq.html#do-i-need-to-read-the-entire-referencing-guide"
  },"31": {
    "doc": "Referencing FAQ",
    "title": "Can an OAD be completely “de-referenced” by “removing” all references?",
    "content": "In general, no. But in many common cases, yes, and tools exist that will attempt this. There are two types of reasons why de-referenceing might not be possible: . | Technical reasons: . | Cyclic references are allowed in Schema Objects, and are used to describe recursive tree structures. JSON Schema itself is a recursive tree structure, so the JSON Schema metaschemas cannot be fully de-referenced (see draft-07 or earlier for how this works with \"$ref\"; draft 2020-12 uses a different technique) | Cyclic references can also occur when describing complex payloads such as multipart/form-data where media type descriptions can be nested | References in Link Objects (\"operationRef\") and Discriminator Objects (\"mapping\") cannot be replaced with literal values, although there are alternatives to using references in these cases (\"operationId\" and mapping by schema component name, respectively, althouogh there can be challenges with arranging the documents properly for those techniques as well) | Dynamic references in OAS 3.1 (which are not covered in detail by this guide) have runtime behavior which cannot always be predicted ahead of time | . | Social reasons: . | In large-scale API ecosystems, different parts of an API may be owned by different entities and connected by references | Independent deployment of different parts of the API and different documents within the OpenAPI Description may make de-referencing impossible, or at least very fragile | Security or other policies may forbid the sort of copying necessary to perform de-referencing; this is most likely to happen in high-security environments such as government or military | Standards compliance policies might require referencing the OAD or schema published by a standards body, rather than copying it | . | . ",
    "url": "/referencing/faq.html#can-an-oad-be-completely-de-referenced-by-removing-all-references",
    
    "relUrl": "/referencing/faq.html#can-an-oad-be-completely-de-referenced-by-removing-all-references"
  },"32": {
    "doc": "Referencing FAQ",
    "title": "Can an OAD at least be de-referenced to a single document?",
    "content": "Technically, yes, although in some cases this is more complex than it may seem: . The following sorts of references cannot be removed and replaced with their (possibly modified, depending on the OAS version an source object) targets. In some cases an alternate technique can be used, while in others the reference value must be updated to reflect the structure of the single consolidated document: . | cyclic references | \"operationRef\" in Link Objects (although if \"operationId\"s are managed carefully, \"operationRef\" can be replaced by \"operationId\") | \"mapping\" in Discriminator Objects (although URI-reference values can be replaced with names from the Components Object if handled correctly) | . Dynamic references, which are outside the scope of this guide, may need even more complex handling to be preserved in a single-document structure. For OAS 3.1, note that if the \"$id\" keyword is used, tools must be aware of it to successfully perform de-referencing, so check your tool’s documentation carefully. For an example of using \"$id\" in a technique known as “bundling”, see the OpenAPI Blog post JSON Schema bundling finally formalised. However, keep in mind that there are other, non-technical reasons why de-referencing may not be feasible. De-referencing is not a general solution in large-scale API ecosystems. ",
    "url": "/referencing/faq.html#can-an-oad-at-least-be-de-referenced-to-a-single-document",
    
    "relUrl": "/referencing/faq.html#can-an-oad-at-least-be-de-referenced-to-a-single-document"
  },"33": {
    "doc": "Referencing FAQ",
    "title": "How is reference “resolution” different from “de-referencing”?",
    "content": "A reference is said to be resolved within a tool if: . | Its target has been identified | Any modifications to the target required by the OAS have been performed | The resulting value has been associated with the reference source in some way that the tool can easily use when needed | . While plain JSON documents form a tree structure, an OpenAPI Description with resolved references is not a tree, but a graph. ",
    "url": "/referencing/faq.html#how-is-reference-resolution-different-from-de-referencing",
    
    "relUrl": "/referencing/faq.html#how-is-reference-resolution-different-from-de-referencing"
  },"34": {
    "doc": "Referencing FAQ",
    "title": "Do I need to understand dynamic references?",
    "content": "This guide does not cover OAS 3.1 / JSON Schema draft 2020-12’s dynamic references (\"$dynamicRef\" and \"$dynamicAnchor\"). Dynamic references seve a different purpose than discussed here. The following JSON Schema Blog posts explain some uses of dynamic references and anchors: . | Using Dynamic References to Support Generic Types | Validating OpenAPI and JSON Schema | . Note that in some cases, \"$dynamicRef\" cannot be removed or de-referenced, as it will evaluate differently depending on how it is reached at runtime. ",
    "url": "/referencing/faq.html#do-i-need-to-understand-dynamic-references",
    
    "relUrl": "/referencing/faq.html#do-i-need-to-understand-dynamic-references"
  },"35": {
    "doc": "Getting Started",
    "title": "Getting started",
    "content": " ",
    "url": "/#getting-started",
    
    "relUrl": "/#getting-started"
  },"36": {
    "doc": "Getting Started",
    "title": "Intended Audience",
    "content": "This guide is directed at HTTP-based API designers and writers wishing to benefit from having their API formalized in an OpenAPI Description document. Machine-readable API descriptions are ubiquitous nowadays and OpenAPI is the most broadly adopted industry standard for describing new APIs. It is therefore worth learning it and getting it right from the start. These pages are a companion to the OpenAPI Specification, helping the reader learn it and answering questions like “What is the best way to accomplish… ?” or “What is the purpose of… ?” that are naturally out of the scope of the specification. | If you are unsure if this guide is for you, read the next section below. | If you do not know what “API”, “machine-readable description” or “OpenAPI” mean start by reading the Introduction chapter. | If this is your first time writing an OpenAPI Description document read The OpenAPI Specification explained chapter for step-by-step tutorials. | If you already have OpenAPI experience but need help with a specific topic, take a look at the index of The OpenAPI Specification explained chapter; it also includes advanced topics. | Finally, make sure you are aware of the recommended Best Practices to take full advantage of OpenAPI! | And of course, you can always refer to the actual OpenAPI Specification for reference. | . ",
    "url": "/#intended-audience",
    
    "relUrl": "/#intended-audience"
  },"37": {
    "doc": "Getting Started",
    "title": "Advantages of Using OpenAPI",
    "content": "Having your API formally described in a machine-readable format allows automated tools to process it, instantly opening the door to: . | Description Validation and Linting: Check that your description file is syntactically correct and adheres to a specific version of the Specification and the rest of your team’s formatting guidelines. | Data Validation: Check that the data flowing through your API (in both directions) is correct, during development and once deployed. | Documentation Generation: Create traditional human-readable documentation based on the machine-readable description, which always stays up-to-date. | Code Generation: Create both server and client code in any programming language, freeing developers from having to perform data validation or write SDK glue code, for example. | Graphical Editors: Allow easy creation of description files using a GUI instead of typing them by hand. | Mock Servers: Create fake servers providing example responses which you and your customers can start testing with before you write a single line of code. | Security Analysis: Discover possible vulnerabilities at the API design stage instead of much, much later. | . On top of this, the OpenAPI Specification also provides you with: . | A non-proprietary format: You have a say in the future direction of the Specification! | The most developed tooling ecosystem: As a direct result of the previous statement, OpenAPI offers a vast number of tools to work with it. Just take a quick look at OpenAPI Tooling. | A format readable by both machines and humans: Even though writing OpenAPI documents by hand is not the most convenient way of doing it (See Best Practices), they are plain text files which can be easily browsed in case something needs to be debugged. | . So, choose your desired entry point from the list at the top of this page and start your journey! . ",
    "url": "/#advantages-of-using-openapi",
    
    "relUrl": "/#advantages-of-using-openapi"
  },"38": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"39": {
    "doc": "Using References",
    "title": "Using References in OpenAPI Descriptions",
    "content": "Confusion over how and why to use references in OpenAPI Descriptions (OADs) is common, as is confusion over how tools can or should be configured to handle them. This guide will explain how both simple and complex referencing scenarios work, and when and why you should consider more complex referencing scenarios. | Referencing FAQ | What are References? | Resolving References | . ",
    "url": "/referencing/#using-references-in-openapi-descriptions",
    
    "relUrl": "/referencing/#using-references-in-openapi-descriptions"
  },"40": {
    "doc": "Using References",
    "title": "Using References",
    "content": " ",
    "url": "/referencing/",
    
    "relUrl": "/referencing/"
  },"41": {
    "doc": "The OpenAPI Specification Explained",
    "title": "The OpenAPI Specification Explained",
    "content": "The OpenAPI Specification is the ultimate source of knowledge regarding this API description format. However, its length is daunting to newcomers and makes it hard for experienced users to find specific bits of information. This chapter provides a soft landing for readers not yet familiar with OpenAPI and is organized by topic, simplifying browsing. The following pages introduce the syntax and structure of an OpenAPI document, its main building blocks and a minimal API document. Afterwards, the different blocks are detailed, starting from the most common and progressing towards advanced ones. | Structure of an OpenAPI Document: JSON, YAML, openapi and info | API Endpoints: paths and responses. | Content of Message Bodies: content and schema. | Parameters and Payload of an Operation: parameters and requestBody. | Reusing Descriptions: components and $ref. | Providing Documentation and Examples: example and examples. | API Servers: servers. | . ",
    "url": "/specification/",
    
    "relUrl": "/specification/"
  },"42": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "The OpenAPI Specification allows the description of a remote API accessible through HTTP or HTTP-like protocols. This chapter explains why this is a good thing and why it might interest you. The concept of an “API” is described first and the advantages of describing APIs using a machine-readable format are introduced, followed by the benefits of using the OpenAPI format. In the last section, the evolution of API descriptions is put into perspective with a brief historical summary. If you are already familiar with the benefits of machine-readable API descriptions and the OpenAPI in particular you may skip ahead to the next chapter, The OpenAPI Specification explained. ",
    "url": "/introduction.html",
    
    "relUrl": "/introduction.html"
  },"43": {
    "doc": "Introduction",
    "title": "What Is an API?",
    "content": "An Application Programming Interface (API) defines the allowed interactions between two pieces of software, just like a User Interface defines the ways in which a user can interact with a program. An API is composed of the list of possible methods to call (requests to make), their parameters, return values and any data format they require (among other things). This is equivalent to how a user’s interactions with a mobile phone app are limited to the buttons, sliders and text boxes in the app’s User Interface. APIs can be local, where both interacting parties run on the same machine. For example, the Windows API offered by the Operating System to its applications, the Standard C Library offered by any C compiler to the programs being compiled, or the TensorFlow API offered by this machine learning library to programs using it. This documentation, though, focuses on remote APIs, where the interacting parties run on separate machines and communicate over a network. For example, a public weather service offering up machine-readable forecasts to be consumed by web pages or mobile applications, or Twitter allowing third-party applications to send messages through its network. To wrap up the definitions, the party offering up its services through an API is called the provider and the one requesting these services is the consumer. Using APIs is an everyday practice in computer science since their benefits are unquestionable. To name only the most prominent: . | APIs provide information hiding: neither side of the API (the provider and the consumer) know the implementation details of the other one. As long as both adhere to the API, they can be changed as much as needed without the other party even noticing. | APIs are also called Contracts, because they are assumed to be unbreakable: The provider promises not to change its API and to keep honoring it in the years to come. With this promise in hand consumers can start developing their parts and rely on the functionality offered up by the API with confidence. | . Now, in order for all involved parties to adhere to the same API it has to be precisely defined. The next section describes how this has traditionally been achieved. ",
    "url": "/introduction.html#what-is-an-api",
    
    "relUrl": "/introduction.html#what-is-an-api"
  },"44": {
    "doc": "Introduction",
    "title": "API Definition Through Documentation",
    "content": "APIs are typically accompanied by a reference guide; a piece of literature explaining to a developer how to use the API. Unfortunately, everybody working on software development is familiar with one or more of the following problems: . | Unclear documentation, leading to mistakes due to interpretation differences. | Incomplete or non-existing documentation. | Outdated information. | Information in a language the reader does not understand. | . In these cases, to find the information they require developers might have to read source code (if available), debug programs or analyze network traffic, which are gigantic time sinks. Furthermore, errors in the usage of an API defined through its documentation cannot be discovered until runtime, which is another time sink. The next section shows how some of these problems can be alleviated by specifying APIs in a format that automated tools can use. ",
    "url": "/introduction.html#api-definition-through-documentation",
    
    "relUrl": "/introduction.html#api-definition-through-documentation"
  },"45": {
    "doc": "Introduction",
    "title": "API Definition Through a Description File",
    "content": "An API description file (sometimes called Contract) is a machine-readable specification of an API. It should strive to be as complete, and fully-detailed as possible, although absolute completeness is not usually a requirement. Also, just like legal contracts, the more unambiguous it is, the more useful it becomes. Its main advantage over documentation which only humans can read is that it enables automated processing, opening the door to the benefits listed at the beginning of this guide. To begin with, documentation for humans including the list of available methods and their details can be easily generated from the API description file. Done as a step in the build process, this easily prevents out-of-sync docs. Furthermore, a tool can use the API description to generate boilerplate code (in any programming language) to build provider and consumer applications. Only the business logic needs to be added and the generated code takes care of all the API handling, removing another source of mistakes and making sure that the code and the documentation match. Additionally, if the data passed to the API must satisfy any constraint it can be automatically verified by the boilerplate code, removing even more manual code. To name only another possibility, the API description file might include examples, and these examples can be used as responses from auto-generated mock servers. This enables early API testing, even before the API provider code is written. For all the above reasons and many more it is highly advisable to use a machine-readable description when designing a new API. Over the years several API description formats (called Specifications) emerged. The following section lists the benefits of OpenAPI, the most widely used specification when creating new APIs. ",
    "url": "/introduction.html#api-definition-through-a-description-file",
    
    "relUrl": "/introduction.html#api-definition-through-a-description-file"
  },"46": {
    "doc": "Introduction",
    "title": "The OpenAPI Specification",
    "content": "The OpenAPI Specification (OAS) is a vendor neutral description format for HTTP-based remote APIs. It was originally based on the Swagger 2.0 Specification, donated by SmartBear Software in 2015. Currently, the OAS is maintained, evolved and promoted by the OpenAPI Initiative (OAI), a consortium of industry experts with an open governance structure under the Linux Foundation umbrella. This means all meetings and decisions are public and changes to the OAS can be proposed and discussed by anyone. This openness has encouraged the creation of a vast amount of tools (take a look at the OpenAPI tools list, for example) which perfectly showcase the power of open, machine-readable API descriptions (called documents in OpenAPI). It’s probably because of the amount of tools available when working with OpenAPI that it has become the most broadly adopted industry standard for describing modern APIs. It is also worth mentioning that the OAS does not aim at being able to describe every possible API, since doing so would require a rather large and unwieldy specification. Instead, it tries to describe efficiently the most common use cases. Still, the benefits provided by OpenAPI are so numerous that it is usually worth it to design your API so it can be fully defined using the OAS. If parts of your API cannot be described using the OAS, and they cannot be redesigned, they can still be left out of the OAS document: OpenAPI lists operations that you can do, but it does not assert anything regarding operations not in the OAS document. Finally, OpenAPI can describe APIs based on the HTTP protocol (like RESTful ones) but also APIs based on HTTP-like protocols like CoAP (Constrained Application Protocol) or WebSockets. This allows OpenAPI to be used in resource-restricted scenarios like IoT (Internet of Things), for example. Feel free to jump now to the next chapter, The OpenAPI Specification explained, to start learning how to use the OAS. Or stay a bit longer to gain historical perspective with a comparison of the evolution of local and remote API descriptions. ",
    "url": "/introduction.html#the-openapi-specification",
    
    "relUrl": "/introduction.html#the-openapi-specification"
  },"47": {
    "doc": "Introduction",
    "title": "A Brief Historical Comparison",
    "content": "Machine-readable API descriptions are not a new thing, they have been present in local APIs for a long time: For instance, C has method signatures and higher-level languages like Java or C# have Interface definitions. The remote API descriptions shown in this page serve exactly the same purpose and this section should make it clearer what this purpose is to readers more familiar with traditional local APIs. In the dawn of computer science there existed only the Assembly Language. In this language, to call a method provided by another developer, you write your parameters in some agreed-upon memory address using an agreed-upon format and then you transfer control of the program to another agreed-upon memory address. Eventually control returns to your program and you can retrieve any results from yet another agreed-upon memory address. As you can see, there are a lot of items to agree upon, and all of them must be properly documented. A mistake or misunderstanding in any of these items is undetectable while writing the code, and they lead to runtime issues ranging from program malfunction to system crashes. Fortunately, higher-level languages were created which, among other things, provide method signatures. These signatures are part of the code and are therefore machine-readable, allowing for compile-time detection of mismatches: The API provider publishes the signatures of all its methods and the consumer’s compiler ensures that the API is used correctly (to a greater extent than documentation alone). Later on, the Internet arrived and with it appeared remote APIs. HTTP-based APIs, for instance, request a certain resource from a server and expect the response to contain information in a certain format. Initially all this was specified through documentation and the same problems that existed in the Assembly language resurfaced again, namely, if the request was not made in the format expected by the server things would not work, and errors could not be detected at compile-time. Machine-readable API descriptions (including OpenAPI) were then invented to bring to remote APIs the same degree of robustness that method signatures brought to local APIs. Tools do exist now which check that requests are made in the correct format, or even ensure it by generating the request code themselves. The benefits delivered by machine-readable descriptions of remote APIs, though, have far surpassed those of method signatures. For instance, OpenAPI can attach examples and notes to most API sections, to complement the automatically-generated documents, or reuse parts of the description to make the whole file leaner. Learn about all these capabilities and more in the next chapter, The OpenAPI Specification explained. ",
    "url": "/introduction.html#a-brief-historical-comparison",
    
    "relUrl": "/introduction.html#a-brief-historical-comparison"
  },"48": {
    "doc": "Parameters and Payload of an Operation",
    "title": "Parameters and Payload of an Operation",
    "content": "The previous page has shown how to describe an operation’s response format, this is, the output data of an operation. On the other hand, this page shows how to specify the input data, this is, the additional information that complements the endpoint and the operation to fully detail a request. OpenAPI provides two mechanisms to specify input data, parameters and request body (message payload). Parameters are typically used to identify a resource, whereas the message payload provides content for that resource. The edges marked with an asterisk are arrays. The Path Item and Operation Objects are explained in the API Endpoints page. The Media Type and Schema Objects are explained in the Content of Message Bodies page. ",
    "url": "/specification/parameters.html",
    
    "relUrl": "/specification/parameters.html"
  },"49": {
    "doc": "Parameters and Payload of an Operation",
    "title": "The Parameter Object",
    "content": "The parameters field in the Path Item and Operation Objects is an array containing Parameter Objects. When provided in the Path Item Object, the parameters are shared by all operations on that path (which can override individual parameters at the Operation Object level but not remove them). Each Parameter Object describes one parameter with the following mandatory fields: . | in (string): Location of the parameter as shown below. | name (string): Case-sensitive. Must be unique in each location. | . Additional optional fields include: . | description (string): Useful for documentation. Might contain usage examples, for instance. | required (boolean): Whether this parameter must be present or not. The default value is false. | . The type of the parameters, their format and their serialization can be specified using additional fields as shown in the next sections. Parameter Location . Parameters can reside in different locations, indicated by the in field. The most common ones are: . | path: The parameter is part of the route of this operation (and hence of its URL). The parameter’s name must appear in the path as a template expression, i.e., delimited by curly braces {}. For example, the path /users/{id} must contain at least one parameter described with: . paths: /users/{id}: get: parameters: - name: id in: path required: true . NOTE: When using path parameters, the required field must be present and it must be true. | query: The parameter is appended to the query string part of the operation’s URL. For example, the URL /users?id=1234 can be parsed using: . paths: /users: get: parameters: - name: id in: query . | header: The parameter is sent in a custom HTTP header as part of the request. Header names are case-insensitive. | . Parameter Type . Most of the time a parameter’s type can be specified by using a Schema Object in the schema field. Schema objects allow defining primitive or complex types (like arrays or objects) and impose additional restrictions on them. For example: . parameters: - name: id in: query schema: type: integer minimum: 1 maximum: 100 . The Content of Message Bodies page describes Schema objects in greater detail. In more advanced scenarios the content field can be used instead. It provides a single-entry map of Media Types to Media Type Objects (More details can be found in the Content of Message Bodies page). NOTE: Exactly one of schema or content must be present. They cannot appear at the same time. Parameter Serialization Control . The style field defines how a parameter is to be serialized and its effect depends on the type of the parameter. The resulting matrix is therefore rather complex and can be consulted in the Parameter Object specification page. The tables given below exemplify the most common styles simple, form, label, and matrix: . | Primitive types: For example, an integer named id with value 1234. | style: | simple | form | label | matrix | . |   | 1234 | id=1234 | .1234 | ;id=1234 | . | Array types: For example, an array named ids containing the integers 1, 2 and 3. The explode field can be used to separate each element of the array into a separate parameter. | style: | simple | form | label | matrix | . | with explode=false | 1,2,3 | ids=1,2,3 | .1.2.3 | ;ids=1,2,3 | . | with explode=true | 1,2,3 | ids=1&amp;ids=2&amp;ids=3 | .1.2.3 | ;ids=1;ids=2;ids=3 | . | Object types: For example, an object named color containing integer fields R, G and B with values 1, 2 and 3. Again, explode can be used to separate each field into a separate parameter. | style: | simple | form | label | matrix | . | with explode=false | R,1,G,2,B,3 | color=R,1,G,2,B,3 | .R.1.G.2.B.3 | ;color=R,1,G,2,B,3 | . | with explode=true | R=1,G=2,B=3 | R=1&amp;G=2&amp;B=3 | .R=1.G=2.B=3 | ;R=1;G=2;B=3 | . | . For more serialization options see the Parameter Object specification. ",
    "url": "/specification/parameters.html#the-parameter-object",
    
    "relUrl": "/specification/parameters.html#the-parameter-object"
  },"50": {
    "doc": "Parameters and Payload of an Operation",
    "title": "The Request Body Object",
    "content": "When updating a record on a database, the parameters are typically used to identify the record whereas the message body provides its new content. The message body of a request is specified through the requestBody field in the Operation Object, which is a Request Body Object. paths: /board: put: requestBody: ... The only mandatory field in the Request Body Object is content which is described in detail in the Content of Message Bodies page. As a reminder, the snippet below describes an operation with a JSON request body containing a single integer with values between 1 and 100. requestBody: content: application/json: schema: type: integer minimum: 1 maximum: 100 . The Request Body Object also has a description string and a required boolean to state whether the message payload is mandatory. ",
    "url": "/specification/parameters.html#the-request-body-object",
    
    "relUrl": "/specification/parameters.html#the-request-body-object"
  },"51": {
    "doc": "Parameters and Payload of an Operation",
    "title": "Tic Tac Toe Example",
    "content": "The Tic Tac Toe sample API contains two endpoints, one without parameters or request body (/board) and another one with both (/board/{row}/{column}). The relevant code snippet for the second endpoint is shown below and it should be easy to understand after reading this page. paths: # Single square operations /board/{row}/{column}: parameters: - name: row in: path required: true schema: type: integer minimum: 1 maximum: 3 - name: column in: path required: true schema: type: integer minimum: 1 maximum: 3 get: summary: Get a single board square responses: ... put: summary: Set a single board square requestBody: required: true content: application/json: schema: type: string enum: [\".\", \"X\", \"O\"] responses: ... | Both operations (get and put) have the same parameters, since they are defined at the Path Item level. | The parameters are two integers, named row and column which are located in the path of the operation. This matches the path name which contains {row} and {column}. | The put operation, additionally, must provide a request body which must be one of the three provided strings: ., X and O. | . The complete Tic Tac Toe sample API does not look exactly like the above snippet because it reuses portions of the document to remove redundancy. This technique is explained in the Reusing Descriptions page. ",
    "url": "/specification/parameters.html#tic-tac-toe-example",
    
    "relUrl": "/specification/parameters.html#tic-tac-toe-example"
  },"52": {
    "doc": "Parameters and Payload of an Operation",
    "title": "Summary",
    "content": "This page has shown: . | How to specify the two types of input data an operation can provide: parameters and requestBody. | Parameters can be located in different places (path, query, headers) and their content (schema) and serialization (style) is highly customizable. | The request body is specified, much like responses are, using the content field. | . The next page explains how to reuse portions of an OpenAPI document to remove redundancy, reducing file size and maintenance cost. ",
    "url": "/specification/parameters.html#summary",
    
    "relUrl": "/specification/parameters.html#summary"
  },"53": {
    "doc": "API Endpoints",
    "title": "API Endpoints",
    "content": "The previous page showed the minimal structure of an OpenAPI document but did not add any operation to the API. This page explains how to do it. ",
    "url": "/specification/paths.html",
    
    "relUrl": "/specification/paths.html"
  },"54": {
    "doc": "API Endpoints",
    "title": "The Endpoints list",
    "content": "API Endpoints (also called Operations or Routes) are called Paths in the OAS. The Paths Object, accessible through the paths field in the root OpenAPI Object, is the container for all operations supported by the API: . The OpenAPI Object is explained in the Structure of an OpenAPI Document page. Every field in the Paths Object is a Path Item Object describing one API endpoint. Fields are used instead of an Array because they enforce endpoint name uniqueness at the syntax level (any JSON or YAML parser can detect mistakes without requiring an OpenAPI validator). Paths must start with a forward slash / since they are directly appended to the server URL (described in the API Servers page) to construct the full endpoint URL. The Tic Tac Toe sample API is used in this guide to exemplify each concept and it is built piece by piece as the guide progresses. Here’s the first snippet already containing a single endpoint: . openapi: 3.1.0 info: title: Tic Tac Toe description: | This API allows writing down marks on a Tic Tac Toe board and requesting the state of the board or of individual squares. version: 1.0.0 paths: /board: ... ",
    "url": "/specification/paths.html#the-endpoints-list",
    
    "relUrl": "/specification/paths.html#the-endpoints-list"
  },"55": {
    "doc": "API Endpoints",
    "title": "The Path Item Object",
    "content": "The Path Item Object describes the HTTP operations that can be performed on a path with a separate Operation Object for each one. Allowed operations match HTTP methods names like get, put or delete, to list the most common (find the complete list in the Path Item Object specification). This object also accepts common properties for all operations on the path like summary or description. The details of each operation are given in each child Operation object. paths: /board: get: ... put: ... ",
    "url": "/specification/paths.html#the-path-item-object",
    
    "relUrl": "/specification/paths.html#the-path-item-object"
  },"56": {
    "doc": "API Endpoints",
    "title": "The Operation Object",
    "content": "Besides giving the operation a summary and a description, the Operation Object basically describes the operation’s parameters, payload and possible server responses. The rest of this page explains the responses field, whereas parameters and payload are dealt with in another page. paths: /board: get: summary: Get the whole board description: Retrieves the current state of the board and the winner. parameters: ... responses: ... ",
    "url": "/specification/paths.html#the-operation-object",
    
    "relUrl": "/specification/paths.html#the-operation-object"
  },"57": {
    "doc": "API Endpoints",
    "title": "The Responses Object",
    "content": "The Responses Object is a container for the expected answers the server can give to this request. Each field name is an HTTP response code enclosed in quotation marks and its value is a Response Object (note there is no ‘s’ at the end) containing details about the response. At least one response must be given and it is recommended that it corresponds to the success case (typically HTTP response code 200). 5 wildcards are allowed: 1XX, 2XX, 3XX, 4XX and 5XX (explicit codes take preference over wildcards). paths: /board: get: responses: \"200\": ... \"404\": ... ",
    "url": "/specification/paths.html#the-responses-object",
    
    "relUrl": "/specification/paths.html#the-responses-object"
  },"58": {
    "doc": "API Endpoints",
    "title": "The Response Object",
    "content": "The Response Object contains a mandatory description of the meaning of the response in the context of this operation, complementing the sense of the HTTP response codes (which are generic in nature). This helps developers understand better how to react to this particular code. The most important field, though, is content because it describes the possible payloads of the response. Due to its complexity, this field’s format is detailed next, in its own page. paths: /board: get: responses: \"200\": description: Everything went fine. content: ... ",
    "url": "/specification/paths.html#the-response-object",
    
    "relUrl": "/specification/paths.html#the-response-object"
  },"59": {
    "doc": "API Endpoints",
    "title": "Tic Tac Toe Example",
    "content": "Here’s a fragment of the example, containing only the objects that have been defined so far in the guide. At this point the reader should be able to understand every line of this snippet. openapi: 3.1.0 info: title: Tic Tac Toe description: | This API allows writing down marks on a Tic Tac Toe board and requesting the state of the board or of individual squares. version: 1.0.0 paths: # Whole board operations /board: get: summary: Get the whole board description: Retrieves the current state of the board and the winner. responses: \"200\": description: \"OK\" content: ... The complete document can be found in the Tic Tac Toe sample API. ",
    "url": "/specification/paths.html#tic-tac-toe-example",
    
    "relUrl": "/specification/paths.html#tic-tac-toe-example"
  },"60": {
    "doc": "API Endpoints",
    "title": "Summary",
    "content": "This page has shown how to specify endpoints (paths), their available operations (get, put, …) and their possible outcomes (responses). The next page shows how to specify the content of the responses. ",
    "url": "/specification/paths.html#summary",
    
    "relUrl": "/specification/paths.html#summary"
  },"61": {
    "doc": "Resolving References",
    "title": "Resolving References",
    "content": "The only difference between URIs and URLs is their intended usage: if a URI is intended to be used as a locator exactly as it is written, then it can be called a URL. API endpoints, for example, are URLs. If a URI is intended to be a stable identifier regardless of where the identified document actually lives, it is a URI, and not a URL. ",
    "url": "/referencing/resolving.html",
    
    "relUrl": "/referencing/resolving.html"
  },"62": {
    "doc": "Resolving References",
    "title": "Resolving internal references",
    "content": "References that consist only of URI fragments, or that have URIs whose non-fragment part resolves to the current document, are easily resolved. For JSON Pointer fragments (the only kind allowed in 3.0, and the only kind allowed outside of Schema Objects in 3.1), all that is needed is to evaluate the pointer against the document. OAS 3.1 Schema Objects and internal references . Static references to plain-name URI fragments . With OAS 3.1 Schema Objects, it is also possible to use plain-name URI fragments in both static (\"$ref\") and dynamic (\"$dynamicRef\") references. Furthermore, it is possible to use \"$id\" to embed a Schema Object with a different absolute-URI from the overall document inside that document. While these references are still internal to the document, they require that the whole document has been parsed, and the keywords that declare the absolute-URIs (\"$id\") or plain-name URI fragments (\"$anchor\" and \"$dynamicAnchor\") have been recognized. As we will see, these scenarios add complexity to resolving external references, as the correct document must be identified and parsed in full before the reference can be resolved. Dynamic references . In the case of \"$dynamicAnchor\" and \"$dynamicRef\", all schema documents containing Schema Objects with \"$dynamicAnchor\" along the evaluation path (following \"$ref\" and \"$dynamicRef\" rather than the literal file structure) of any given instance validation must be parsed and recognized in order to properly resolve the \"$dynamicRef\" for that instance validation. Dynamic references cannot be fully resolved except in the context of instance evaluation/validation. This is true for both internal and external dynamic references. In particular, a \"$dynamicRef\" will always be statically resolvable (treating it like \"$ref\") to a \"$dynamicAnchor\" in the same document, making all \"$dynamicRef\"s appear to be internal references. However, if the \"$dynamicRef\" is reached through any external documents on a particular evaluation path, then it will at least potentially function as an external reference. ",
    "url": "/referencing/resolving.html#resolving-internal-references",
    
    "relUrl": "/referencing/resolving.html#resolving-internal-references"
  },"63": {
    "doc": "Resolving References",
    "title": "Resolving external references",
    "content": "External references, which are references with a target URI pointing to a different document than the one containing the reference, can be handled in several different ways. The OpenAPI Specification is not clear on the exact requirements, although the JSON Schema Specification makes it clear that references are done through identifiers (URIs) rather than locators (URLs) (draft-wright-00 for OAS 3.0; draft-bhutton-00 for OAS 3.1). Not all tools support external references at all, and some that do only support handling them as URLs. This guide will examine different approaches, but check your tool documentation for what is supported in your environment. Treating reference URIs as URLs . The simplest way to resolve external references is to just treat the URIs as URLs. This works if either your OAD documents are always located in the same place, or if you can use relative URI-references to handle the difference between (for example) local check-outs of your files vs various development, testing, and production deployments. However, some use cases make treating reference identifiers as locators challenging: . | Maintaining both JSON and YAML formats, when using file extensions to differentiate them | OADs that reference 3rd-party schemas from disparate sources | . Use cases for separating identity (URIs) and location (URLs) . There are many reasons to separate reference identity and location. This section will briefly list a few, while the next section will use an analogy to make the benefits more concrete for those who have only worked with relatively simple OpenAPI Descriptions (OADs). Note that the versions of JSON Schema referenced by OAS 3.0 and 3.1 explicitly state that reference use URIs as identifiers, not necessarily locators. Tools that support separating reference identity and location provide various ways to map reference URIs to actual URLs to resolve the references. These interfaces vary widely, so check your tool’s documentation to determine what reference resolution configuration it supports. Use cases for mapping references to locations other than that given by their URI include: . | Abstracting JSON vs YAML representaitons by omitting any file extension (otherwise you need different reference values in each format, or you will change formats as you follow references which is allowed but may be surprising to users) | Using an internal mirror of a 3rd-party schema repository in a high-security environment | Managing references that are too complex to handle with relative URI-references alone, such as when you are mixing shared production schemas or other components with local development or tests schemas or components | . An analogy with programming language package managers . TBD; see OAI/moonwalk#49 (comment) for a first pass at this example. ",
    "url": "/referencing/resolving.html#resolving-external-references",
    
    "relUrl": "/referencing/resolving.html#resolving-external-references"
  },"64": {
    "doc": "API Servers",
    "title": "API Servers",
    "content": "This page shows how to specify the server where the API can be accessed, which can contain multiple URLs and even variable portions. ",
    "url": "/specification/servers.html",
    
    "relUrl": "/specification/servers.html"
  },"65": {
    "doc": "API Servers",
    "title": "The Server Object",
    "content": "The Server Object provides the base URLs where the API is being served. It can be found in the servers array present in the root OpenAPI Object, the Path Item Object and the Operation Object. The edges marked with an asterisk are arrays.The OpenAPI Object is explained in the Structure of an OpenAPI Document page.The Paths, Path Item and Operation Objects are explained in the API Endpoints page. Each element in a servers array is a Server Object providing, at least, a url field with the base URL for that server. An optional description aids in keeping server lists organized: . servers: - url: https://europe.server.com/v1 description: Server located in Germany. - url: https://america.server.com/v1 description: Server located in Atlanta, GA. - url: https://asia.server.com/v1 description: Server located in Shenzhen . Individual API endpoints (as specified in the Paths Object) are then appended to this URL to construct the full endpoint URL. For example: . servers: - url: https://server.com/v1 paths: /users: get: . The above operation can be accessed by executing a GET request on the URL https://server.com/v1/users. When multiple servers arrays are specified at different levels for a given operation, only the lowest level one is taken into account. For example, in this case: . servers: - url: https://server1.com paths: /users: get: servers: - url: https://server2.com . GET requests to the /users endpoint are served from https://server2.com and not from https://server1.com. NOTE: When providing multiple servers in an OpenAPI document keep in mind that they should all provide the same API (since they are being listed in the same document). If the servers are used for different environments (for example Testing and Production), chances are that their APIs will be different and describing them in a single document will be complicated. In these cases it is probably better to use different documents, and even different API versions. Read the Reusing Descriptions page to learn how to avoid code duplication and maintenance costs in these scenarios. Conversely, if no servers are provided, it is assumed that all API endpoints are relative to the location where the OpenAPI document is being served. Finally, the server URLs can contain variable portions, as shown next. ",
    "url": "/specification/servers.html#the-server-object",
    
    "relUrl": "/specification/servers.html#the-server-object"
  },"66": {
    "doc": "API Servers",
    "title": "Server Variables",
    "content": "Server URLs can contain variables, delimited by curly braces {}: . servers: - url: https://{username}.server.com:{port}/{version} . These variables must then be further detailed in the variables field. This field is a map pairing variable names (matching the ones in curly braces in the server’s url) and Server Variable Objects. The Server Variable Object has the following fields: . | default (string): This is a mandatory field and it is the value that should be used if there is no other value to provide. | enum (array of strings): If present, this array lists the valid values for the variable (and the default value must be in the array). | description (string): Documentation always helps understand the purpose of a variable. | . Therefore, the above example could be extended like this: . servers: - url: https://{username}.server.com:{port}/{version} variables: username: default: demo description: This value is assigned by the service provider. port: enum: - \"8443\" - \"443\" default: \"8443\" version: default: v1 . NOTE: The default variable value works differently than the default Schema Object value used in other parts of the OpenAPI Specification. The latter is optional, meaning that if a Schema Object value is not provided it should be assumed to be the default value. On the other hand, server variables must always be provided. ",
    "url": "/specification/servers.html#server-variables",
    
    "relUrl": "/specification/servers.html#server-variables"
  },"67": {
    "doc": "API Servers",
    "title": "Summary",
    "content": "This page has shown that: . | Server lists can be provided through the servers array. | This array is present at different levels (OpenAPI Object, Path Item Object and Operation Object) and only the innermost one is used. | Server URLs can contain variables for further customization like https://{username}.server.com:{port}/{version} | . ",
    "url": "/specification/servers.html#summary",
    
    "relUrl": "/specification/servers.html#summary"
  },"68": {
    "doc": "Structure of an OpenAPI Document",
    "title": "Structure of an OpenAPI Document",
    "content": "An OpenAPI document describes an HTTP-like API in one or more machine-readable files. This page describes the syntax of these files and the minimal structure they must contain. ",
    "url": "/specification/structure.html",
    
    "relUrl": "/specification/structure.html"
  },"69": {
    "doc": "Structure of an OpenAPI Document",
    "title": "Document Syntax",
    "content": "An OpenAPI document is a text file, commonly called openapi.json or openapi.yaml, representing a JSON object, in either JSON or YAML format. This file is called the root document and it can be split into multiple JSON or YAML files, for clarity. This section very briefly describes these two formats and compares them. JSON can represent Numbers, Strings, Booleans, null values, Arrays and Objects. An array is an ordered list of values which can have different types. An object (also called a Map) is a collection of name-value pairs where the names (also called Keys or Fields) are unique within the object and the values can have any of the supported types (including other objects or arrays). Here’s a comparison showing the different syntaxes. JSON: . { \"anObject\": { \"aNumber\": 42, \"aString\": \"This is a string\", \"aBoolean\": true, \"nothing\": null, \"arrayOfNumbers\": [ 1, 2, 3 ] } } . YAML: . # Anything after a hash sign is a comment anObject: aNumber: 42 aString: This is a string aBoolean: true nothing: null arrayOfNumbers: - 1 - 2 - 3 . Basically, JSON does not support comments and requires: commas separating fields, curly brackets around objects, double quotation marks around strings and square brackets around arrays. On the other hand, YAML requires hyphens before array items and relies heavily on indentation, which can be cumbersome on large files (indentation is entirely optional in JSON). YAML is typically preferred because of its slightly reduced file size, but the two formats are completely interchangeable (as long as YAML 1.2 is used). All examples in these pages will be given in YAML. However, YAML being a superset of JSON means that both syntaxes can be mixed. While this is not recommended in general, it can come in handy sometimes. For example: . anObject: aString: This is a string arrayOfNumbers: [ 1, 2, 3 ] # Abbreviated array representation . Finally, object field names are case-sensitive: openapi is not the same thing as OpenAPI. NOTE: Ellipses (…) are used throughout this guide to indicate an incomplete code snippet. Ellipses are not part of JSON or YAML. ",
    "url": "/specification/structure.html#document-syntax",
    
    "relUrl": "/specification/structure.html#document-syntax"
  },"70": {
    "doc": "Structure of an OpenAPI Document",
    "title": "Minimal Document Structure",
    "content": "To be entirely precise, an OpenAPI document is a single JSON object containing fields adhering to the structure defined in the OpenAPI Specification (OAS). The OAS structure is long and complex so this section just describes the minimal set of fields it must contain, while following pages give more details about specific objects. The OpenAPI Map is a nice visual tool that can help familiarize the reader with this long specification. The root object in any OpenAPI document is the OpenAPI Object and only two of its fields are mandatory: openapi, and info. Additionally, at least one of paths, components and webhooks is required. | openapi (string): This indicates the version of the OAS this document is using, e.g. “3.1.0”. Using this field tools can check that the document correctly adheres to the spec. | info (Info Object): This provides general information about the API (like its description, author and contact information) but the only mandatory fields are title and version. | title (string): A human-readable name for the API, like “GitHub REST API”, useful to keep API collections organized. | version (string): Indicates the version of the API document (not to be confused with the OAS version above). Tools can use this field to generate code that ensures that clients and servers are interacting through the same version of the API, for example. | . | paths (Paths Object): This describes all the endpoints of the API, including their parameters and all possible server responses. Server and client code can be generated from this description, along with its documentation. | . Diagrams are used in this guide to show the relationship between the different objects. Here’s an example of a minimal OpenAPI document: . openapi: 3.1.0 info: title: A minimal OpenAPI document version: 0.0.1 paths: {} # No endpoints defined . This API is not very useful because it defines no operations (it has no endpoints). The next page remedies that. ",
    "url": "/specification/structure.html#minimal-document-structure",
    
    "relUrl": "/specification/structure.html#minimal-document-structure"
  },"71": {
    "doc": "Structure of an OpenAPI Document",
    "title": "Summary",
    "content": "This page has shown that: . | The syntax (language) used to write OpenAPI documents can be JSON, YAML or both. | An OpenAPI document is a JSON object including the fields described in the OpenAPI Specification. | Every OpenAPI document must contain a root object with at least the fields openapi, and info, and either paths, components or webhooks. | . The following page describes the contents of the paths field so endpoints can be added to the above minimal snippet. ",
    "url": "/specification/structure.html#summary",
    
    "relUrl": "/specification/structure.html#summary"
  },"72": {
    "doc": "What Are References?",
    "title": "What are references?",
    "content": "A reference is a keyword and value that identifies a reference target with a URI. In some cases, this URI can be treated as a URL and de-referenced directly. In other cases, as we will see in the resolving references guide, it is helpful to separate the target’s identity from its location. External references are how multiple documents are linked into an OAD. This means that referencing impacts how other linkages, such as those that use Components Object names, or values such as operationId in the Path Item Object, work. These other linkages can only work if the document (or with many tools, the specific JSON object) containing the name or other identifier has been referenced. ",
    "url": "/referencing/what.html#what-are-references",
    
    "relUrl": "/referencing/what.html#what-are-references"
  },"73": {
    "doc": "What Are References?",
    "title": "A taxonomy of references",
    "content": "References exist in several variations in the OpenAPI Specification (OAS) versions 3.0 and 3.1, as shown in the following table. Note that an adjacent keyword is a keyword in the same JSON Object (whether it is written in JSON or YAML) as the reference keyword. | OAS Version | Object | Reference Keyword | Adjacent Keywords | Behavior | . | 3.0 | Reference Object | \"$ref\" | ignored | logically replace the Reference Object with the reference target | . | 3.1 | Reference Object | \"$ref\" | \"summary\" and \"description\" allowed; others ignored | logically replace the Reference Object with a coply of the target, overwriting the target’s \"summary\" and/or \"description\" fields with those of the Reference Object if they are present | . | 3.x | Path Item Object | \"$ref\" | allowed under some circumstances | logically replace the Path Item Object containing the \"$ref\" with a Path Item Object that combines the fields of the target Path Item Object with the non-\"$ref\" fields of the Path Item Object containing the \"$ref\", as long as none of those fields conflict | . | 3.1 | Schema Object | \"$ref\" | allowed | Apply the target Schema Object to the same instance location as the Schema Object containing the \"$ref\", and combine the results with the results of other keywords in the Schema Object containing the \"$ref\" just as you would any other keyword results; this is more-or-less equivalent to using a one-element \"allOf\" | . | 3.x | Link Object | \"operationRef\" | allowed, except \"operationId\" | Treat the reference target as the target of the link described by the Link Object | . | 3.x | Descriminator Object | \"mapping\" | n/a | for each name under \"mapping\", if the value is not the name of a Schema Object under the Components Object, treat it as a reference to the schema to use when the discriminator field matches the mapping name | . Note that not all references are handled by replacing the source with the target. Some are defined in terms of behavior, and cannot be replaced with an inline value. URIs, URLs, and URI-references . All of the above keywords take a URI-reference as a value, which can be either a URI (which MUST include a scheme) or a relative reference, which must be resolved against a base URI to produce a full URI. In this guide, the term URI-reference resolution is always used for the process of resolving a URI-reference against a base URI. Somewhat confusingly, the OAS uses the the terms “URI” and “URL” to mean “URI or URI-reference” and “URL or URL-reference”, respectively. In this guide, whenever a reference’s “URI” is mentioned, it is always refers to the proper URI after any necessary URI-reference resolution has been performed. Also, in this guide the term “reference” alone always means reference as defined in the table above, and the words “resolve”, “resolved”, and “resolution” on their own always refer to the OAS-defined process that occurs after URI-reference resolution. ",
    "url": "/referencing/what.html#a-taxonomy-of-references",
    
    "relUrl": "/referencing/what.html#a-taxonomy-of-references"
  },"74": {
    "doc": "What Are References?",
    "title": "Non-reference linkages",
    "content": "The following connections between parts of the OAS require that some name or identifier has been seen. Due to ambiguities in the specification (which the OAI will hopefully be able to clarify in future patch releases), it is not always clear how to handle identifiers that are present in a document that has been referenced, but are not present in the exact JSON object targeted by any single reference. Note that some of the identifiers are not in objects that can be referenced, but are included for completeness. | OAS Version | Identifying Object | Identifying Field | Object of Identifier Use | . | 3.x | Components Object | Schema name | Discriminator Object | . | 3.x | Components Object | Security Scheme name | Security Requirement Object | . | 3.x | Tag Object | name | Operation Object | . | 3.x | Operation Object | operationId | Link Object | . | 3.x | Server Object | n/a | Paths Object | . ",
    "url": "/referencing/what.html#non-reference-linkages",
    
    "relUrl": "/referencing/what.html#non-reference-linkages"
  },"75": {
    "doc": "What Are References?",
    "title": "JSON Schema referencing and identification in OAS 3.1",
    "content": "In OAS 3.1, JSON Schema combines some of the concerns of referencing and non-reference linkage. This is because in JSON Schema draft 2020-12 as included in OAS 3.1, the dialect can be set within the OAD, or through the \"$schema\" keyword in a parent Schema Object. Schemas can also be referenced by URIs declared in-schema by certain keywords. These can be URIs that cannot be used as URLs as they are not hosted separately from the containing document, or plain-name fragments that, unlike JSON Pointer fragments, can only be resolved if their delcaring keyword has been parsed. | Identifier Purpose | Identifying Object | Identifying Field | . | dialect id | OpenAPI Object | jsonSchemaDialect | . | dialect id | Schema Object | $schema | . | static reference target | Schema Object | $id | . | static reference target | Schema Object | $anchor | . | dynamic reference target | Schema Object | $dynamicAnchor | . ",
    "url": "/referencing/what.html#json-schema-referencing-and-identification-in-oas-31",
    
    "relUrl": "/referencing/what.html#json-schema-referencing-and-identification-in-oas-31"
  },"76": {
    "doc": "What Are References?",
    "title": "What Are References?",
    "content": " ",
    "url": "/referencing/what.html",
    
    "relUrl": "/referencing/what.html"
  }
}
