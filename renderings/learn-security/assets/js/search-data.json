{"0": {
    "doc": "Best Practices",
    "title": "Best Practices",
    "content": "This page contains general pieces of advice which do not strictly belong to the Specification Explained chapter because they are not directly tied to the OpenAPI Specification (OAS). However, they greatly simplify creating and maintaining OpenAPI Descriptions (OADs), so they are worth keeping in mind. ",
    "url": "/best-practices.html",
    
    "relUrl": "/best-practices.html"
  },"1": {
    "doc": "Best Practices",
    "title": "Use a Design-First Approach",
    "content": "Traditionally, two main approaches exist when creating OADs: Code-first and Design-first. | In the Code-first approach, the API is first implemented in code, and then its description is created from it, using code comments, code annotations or simply written from scratch. This approach does not require developers to learn another language so it is usually regarded as the easiest one. | Conversely, in Design-first, the API description is written first and then the code follows. The first obvious advantages are that the code already has a skeleton upon which to build, and that some tools can provide boilerplate code automatically. | . There have been a number of heated debates over the relative merits of these two approaches but, in the opinion of the OpenAPI Initiative (OAI), the importance of using Design-first cannot be stressed strongly enough. The reason is simple: The number of APIs that can be created in code is far superior to what can be described in OpenAPI. To emphasize: OpenAPI is not capable of describing every possible HTTP API, it has limitations. Therefore, unless these descriptive limitations are perfectly known and taken into account when coding the API, they will rear their ugly head later on when trying to create an OpenAPI description for it. At that point, the right fix will be to change the code so that it uses an API which can be actually described with OpenAPI (or switch to Design-first altogether). Sometimes, however, since it is late in the process, it will be preferred to twist the API description so that it matches more or less the actual API. It goes without saying that this leads to unintuitive and incomplete descriptions, that will rarely scale in the future. Finally, there exist a number of validation tools that can verify that the implemented code adheres to the OpenAPI description. Running these tools as part of a Continuous Integration process allows changing the OpenAPI Description with peace of mind, since deviations in the code behavior will be promptly detected. Bottom line: OpenAPI opens the door to a wealth of automated tools. Make sure you use them! . ",
    "url": "/best-practices.html#use-a-design-first-approach",
    
    "relUrl": "/best-practices.html#use-a-design-first-approach"
  },"2": {
    "doc": "Best Practices",
    "title": "Keep a Single Source of Truth",
    "content": "Regardless of your design approach (design-first or code-first) always keep a single source of truth, i.e., information should not be duplicated in different places. It is really the same concept used in programming, where repeated code should be moved to a common function. Otherwise, eventually one of the places will be updated while the other won’t, leading to headaches… in the best of cases. For instance, it is also commonplace to use code annotations to generate an OpenAPI description and then commit the latter to source control while the former still lingers in the code. As a result, newcomers to the project will not know which one is actually in use and mistakes will be made. Alternatively, you can use a Continuous Integration test to ensure that the two sources stay consistent. ",
    "url": "/best-practices.html#keep-a-single-source-of-truth",
    
    "relUrl": "/best-practices.html#keep-a-single-source-of-truth"
  },"3": {
    "doc": "Best Practices",
    "title": "Add OpenAPI Descriptions to Source Control",
    "content": "OpenAPI Descriptions are not just a documentation artifact: they are first-class source files which can drive a great number of automated processes, including boilerplate generation, unit testing and documentation rendering. As such, OADs should be committed to source control, and, in fact, they should be among the first files to be committed. From there, they should also participate in Continuous Integration processes. ",
    "url": "/best-practices.html#add-openapi-descriptions-to-source-control",
    
    "relUrl": "/best-practices.html#add-openapi-descriptions-to-source-control"
  },"4": {
    "doc": "Best Practices",
    "title": "Make the OpenAPI Descriptions Available to the Users",
    "content": "Beautifully-rendered documentation can be very useful for the users of an API, but sometimes they might want to access the source OAD. For instance, to use tools to generate client code for them, or to build automated bindings for some language. Therefore, making the OAD available to the users is an added bonus for them. The documents that make up the OAD can even be made available through the same API to allow runtime discovery. ",
    "url": "/best-practices.html#make-the-openapi-descriptions-available-to-the-users",
    
    "relUrl": "/best-practices.html#make-the-openapi-descriptions-available-to-the-users"
  },"5": {
    "doc": "Best Practices",
    "title": "There is Seldom Need to Write OpenAPI Descriptions by Hand",
    "content": "Since OADs are plain text documents, in an easy-to-read format (be it JSON or YAML), API designers are usually tempted to write them by hand. While there is nothing stopping you from doing this, and, in fact, hand-written API descriptions are usually the most terse and efficient, approaching any big project by such method is highly impractical. Instead, you should try the other existing creation methods and choose the one that better suits you and your team (No YAML or JSON knowledge needed!): . | OpenAPI Editors: Be it text editors or GUI editors they usually take care of repetitive tasks, allow you to keep a library of reusable components and provide real-time preview of the generated documentation. | Domain-Specific Languages: As its name indicates, DSL’s are API description languages tailored to specific development fields. A tool is then used to produce the OpenAPI Description. A new language has to be learned, but, in return, extremely concise descriptions can be achieved. | Code Annotations: Most programming languages allow you to annotate the code, be it with specific syntax or with general code comments. These annotations, for example, can be used to extend a method signature with information regarding the API endpoint and HTTP method that lead to it. A tool can then parse the code annotations and generate OADs automatically. This method fits very nicely with the code-first approach, so keep in mind the first advice given at the top of this page when using it (Use a Design-First Approach)… . | A Mix of All the Above: It’s perfectly possible to create the bulk of an OpenAPI Description using an editor or DSL and then hand-tune the resulting file. Just be aware of the second advice above (Keep a Single Source of Truth): Once you modify a file it becomes the source of truth and the previous one should be discarded (maybe keep it as backup, but out of the sight and reach of children and newcomers to the project). | . ",
    "url": "/best-practices.html#there-is-seldom-need-to-write-openapi-descriptions-by-hand",
    
    "relUrl": "/best-practices.html#there-is-seldom-need-to-write-openapi-descriptions-by-hand"
  },"6": {
    "doc": "Best Practices",
    "title": "Describing Large APIs",
    "content": "This is a collection of small hints related to working with large OADs. | Do not repeat yourself (The DRY principle). If the same piece of YAML or JSON appears more than once in the document, it’s time to move it to the components section and reference it from other places using $ref (See Reusing Descriptions. Not only will the resulting document be smaller but it will also be much easier to maintain). Components can be referenced from other documents, so you can even reuse them across different API descriptions! . | Split the description into several documents: Smaller files are easier to navigate, but too many of them are equally taxing. The key lies somewhere in the middle. A good rule of thumb is to use the natural hierarchy present in URLs to build your directory structure. For example, put all routes starting with /users (like /users and /users/{id}) in the same file (think of it as a “sub-API”). Bear in mind that some tools might have issues with large files, whereas some other tools might not handle too many files gracefully. The solution will have to take your toolkit into account. | Use tags to keep things organized: Tags have not been described in the Specification chapter, but they can help you arrange your operations and find them faster. A tag is simply a piece of metadata (a unique name and an optional description) that you can attach to operations. Tools, specially GUI editors, can then sort all your API’s operation by their tags to help you keep them organized. | . ",
    "url": "/best-practices.html#describing-large-apis",
    
    "relUrl": "/best-practices.html#describing-large-apis"
  },"7": {
    "doc": "Best Practices",
    "title": "Links to External Best Practices",
    "content": "There’s quite a bit of literature about how to organize your API more efficiently. Make sure you check out how other people solved the same issues you are facing now! . For example: . | The API Stylebook contains internal API Design Guidelines shared with the community by some well known companies and government agencies. | . ",
    "url": "/best-practices.html#links-to-external-best-practices",
    
    "relUrl": "/best-practices.html#links-to-external-best-practices"
  },"8": {
    "doc": "Reusing Description",
    "title": "Reusing Descriptions",
    "content": "As is often the case, the example built through the previous pages has grown too large to be easily manageable. This page introduces a mechanism to remove redundancy from an OpenAPI Description (OAD) by reusing portions of it. ",
    "url": "/specification/components.html#reusing-descriptions",
    
    "relUrl": "/specification/components.html#reusing-descriptions"
  },"9": {
    "doc": "Reusing Description",
    "title": "The Components Object",
    "content": "The Components Object, accessible through the components field in the root OpenAPI Object, contains definitions for objects to be reused in other parts of the description. The OpenAPI Object is explained in the Structure of an OpenAPI Description page.The Schema Object is explained in the Content of Message Bodies page.The Response Object is explained in the API Endpoints page.The Parameter Object is explained in the Parameters and Payload of an Operation page. Most objects in an OAD can be replaced by a reference to a component, drastically reducing the OAD’s size and maintenance cost (just like methods do in programming languages). Not all objects can be referenced, though, only those listed as fields of the Components Object like schemas, responses and parameters to name a few. Each field in the Components Object is a map pairing component names with objects to be reused. The type of these objects must match the parent field, e.g. objects in the schemas map must be Schema Objects. components: schemas: coordinate: type: integer minimum: 1 maximum: 3 parameters: rowParam: name: row in: path required: true . The above example defines two components: . | coordinate is a schema component, usable wherever a Schema Object is expected. | rowParam is a parameter component, usable wherever a Parameter Object is expected. | . The next section explains how to reference these components. ",
    "url": "/specification/components.html#the-components-object",
    
    "relUrl": "/specification/components.html#the-components-object"
  },"10": {
    "doc": "Reusing Description",
    "title": "The Reference Object",
    "content": "Any OpenAPI object of the types supported by the Components Object can be replaced by a Reference Object pointing to a component. Reference Objects are actually JSON References: they contain a single field named $ref and its string value is a URI pointing to the referenced object: . $ref: 'https://gigantic-server.com/schemas/Monster/schema.yaml' . References can be absolute or relative, and they can include a fragment identifier . $ref: './another_file.yaml#rowParam' . To complete the example from the previous section: . components: schemas: coordinate: type: integer minimum: 1 maximum: 3 parameters: rowParam: name: row in: path required: true schema: $ref: \"#/components/schemas/coordinate\" columnParam: name: column in: path required: true schema: $ref: \"#/components/schemas/coordinate\" paths: /board/{row}/{column}: parameters: - $ref: \"#/components/parameters/rowParam\" - $ref: \"#/components/parameters/columnParam\" . Note how all references point to different fragments inside the same document (the one being processed). Note also how the coordinate schema is used twice (in the rowParam and columnParam parameters), and how these two parameters are referenced from the /board/{row}/{column} path. ",
    "url": "/specification/components.html#the-reference-object",
    
    "relUrl": "/specification/components.html#the-reference-object"
  },"11": {
    "doc": "Reusing Description",
    "title": "Tic Tac Toe Example",
    "content": "The complete Tic Tac Toe sample API (not included here for brevity) makes heavy use of components. Note for example how different endpoints return a #/components/schemas/status on success, or a #/components/schemas/errorMessage on error. ",
    "url": "/specification/components.html#tic-tac-toe-example",
    
    "relUrl": "/specification/components.html#tic-tac-toe-example"
  },"12": {
    "doc": "Reusing Description",
    "title": "Summary",
    "content": "Whenever the same piece of JSON or YAML is repeated in an OAD, it is probably worth converting it into a component and referencing it everywhere else. Furthermore, Reference Objects allow splitting a description into several documents to keep them organized and their individual size manageable. This page has shown that: . | Reusable Components Objects can be defined by using the components field of the root OpenAPI Object. | Components can be referenced from any place where an object of the same type is expected using $ref. | References are actually URIs so they are very flexible. | . The next page explains how to include documentation and examples in an OpenAPI Description. ",
    "url": "/specification/components.html#summary",
    
    "relUrl": "/specification/components.html#summary"
  },"13": {
    "doc": "Reusing Description",
    "title": "Reusing Description",
    "content": " ",
    "url": "/specification/components.html",
    
    "relUrl": "/specification/components.html"
  },"14": {
    "doc": "Content of Message Bodies",
    "title": "Content of Message Bodies",
    "content": "The previous page showed how to define API endpoints but it didn’t explain how to describe the content of the responses through the content field. This page clarifies this important field, which can also be used to describe queries, as shown in the Parameters page. ",
    "url": "/specification/content.html",
    
    "relUrl": "/specification/content.html"
  },"15": {
    "doc": "Content of Message Bodies",
    "title": "The content Field",
    "content": "This field can be found both in Response Objects and Request Body Objects. It is a map pairing standard RFC6838 Media Types with OpenAPI Media Type Objects. The Response Object is explained in the API Endpoints page.The Request Body Object is explained in the Parameters and Payload of an Operation page. This allows returning content (or accepting content) in different formats, each one with a different structure described by the Media Type Object. Wildcards are accepted for the media types, with the more specific ones taking precedence over the generic ones. content: application/json: ... text/html: ... text/*: ... ",
    "url": "/specification/content.html#the-content-field",
    
    "relUrl": "/specification/content.html#the-content-field"
  },"16": {
    "doc": "Content of Message Bodies",
    "title": "The Media Type Object",
    "content": "The Media Type Object describes the structure of the content and provides examples for documentation and mocking purposes (examples are dealt with in the Documentation page). The structure is described in the schema field explained next. content: application/json: schema: ... ",
    "url": "/specification/content.html#the-media-type-object",
    
    "relUrl": "/specification/content.html#the-media-type-object"
  },"17": {
    "doc": "Content of Message Bodies",
    "title": "The Schema Object",
    "content": "The Schema Object defines a data type which can be a primitive (integer, string, …), an array or an object depending on its type field. type is a string and its possible values are: number, string, boolean, array and object. Depending on the selected type a number of other fields are available to further specify the data format. For example, for string types the length of the string can be limited with minLength and maxLength. Similarly, integer types, accept minimum and maximum values. No matter the type, if the amount of options for the data is limited to a certain set, it can be specified with the enum array. All these properties are listed in the Schema Object specification. Example integer with limited range: . content: application/json: schema: type: integer minimum: 1 maximum: 100 . Example string with only three valid options: . content: application/json: schema: type: string enum: - Alice - Bob - Carl . Array types should have an items field, which is a Schema Object itself, and defines the type for each element of the array. Additionally, the size of the array can be limited with minItems and maxItems. content: application/json: schema: type: array minItems: 1 maxItems: 10 items: type: integer . Finally, object types should have a properties field listing the properties of the object. This field is a map pairing property names with a Schema Object defining their type. This allows building data types as complex as required. Here’s an example defining an object with two fields: a productName string and a productPrice number: . content: application/json: schema: type: object properties: productName: type: string productPrice: type: number . ",
    "url": "/specification/content.html#the-schema-object",
    
    "relUrl": "/specification/content.html#the-schema-object"
  },"18": {
    "doc": "Content of Message Bodies",
    "title": "Tic Tac Toe Example",
    "content": "The Tic Tac Toe sample API given so far has one endpoint with one unspecified response. The snippet below adds the description of this content: . openapi: 3.1.0 info: title: Tic Tac Toe description: | This API allows writing down marks on a Tic Tac Toe board and requesting the state of the board or of individual squares. version: 1.0.0 paths: # Whole board operations /board: get: summary: Get the whole board description: Retrieves the current state of the board and the winner. responses: \"200\": description: \"OK\" content: application/json: schema: type: object properties: winner: type: string enum: [\".\", \"X\", \"O\"] description: | Winner of the game. `.` means nobody has won yet. board: type: array maxItems: 3 minItems: 3 items: type: array maxItems: 3 minItems: 3 items: type: string enum: [\".\", \"X\", \"O\"] description: | Possible values for a board square. `.` means empty square... The response contains an object is JSON format with two fields: . | winner is a string with only three possible values: ., X and O. | board is a 3-element array where each item is another 3-element array, effectively building a 3x3 square matrix. Each element in the matrix is a string with only three possible values: ., X and O. | . This part of our description is starting to grow too big and complex. The details of the response schema take up a lot of space, obscuring the request/response structure. The deep nesting also makes the schema harder to spot within the larger object. The Reusing Descriptions page explains how to name sections of an OpenAPI Description (OAD) in order to reuse them (like the strings with three options above, which appear twice). ",
    "url": "/specification/content.html#tic-tac-toe-example",
    
    "relUrl": "/specification/content.html#tic-tac-toe-example"
  },"19": {
    "doc": "Content of Message Bodies",
    "title": "Summary",
    "content": "This page has shown how to describe the content of the body of a response or query. More precisely: . | The content field maps Media Types to Media Type Objects. | Each Media Type Object has a schema field describing a Schema Object. | Schema Objects define a data type which can be customized through multiple properties like minimum, maximum, items, properties and many more. | . The next page explains how to define the parameters that an endpoint accepts. ",
    "url": "/specification/content.html#summary",
    
    "relUrl": "/specification/content.html#summary"
  },"20": {
    "doc": "Providing Documentation and Examples",
    "title": "Providing Documentation and Examples",
    "content": "Besides machine-readable descriptions, an OpenAPI Description (OAD) can also include traditional documentation meant to be read by developers. Automatic documentation generators can then merge both and produce comprehensive, nicely-structured reference guides, for example. This page shows how to take full advantage of special documentation capabilities in OpenAPI like markdown syntax or example objects. ",
    "url": "/specification/docs.html",
    
    "relUrl": "/specification/docs.html"
  },"21": {
    "doc": "Providing Documentation and Examples",
    "title": "The Description Field",
    "content": "Almost every object in the OpenAPI Specification accepts a description field which can provide additional information for developers, beyond what can be automatically generated from the API descriptions. For instance, a parameter’s name, type and valid range of values are already present in the API description. The description field can complement this information by explaining the purpose of this parameter, the effect of each value or possible interactions with other parameters: . paths: /audio/volume: put: requestBody: required: true content: application/json: schema: type: integer minimum: 0 maximum: 11 description: Current volume for all audio output. 0 means no audio output (mute). 10 is the maximum value. 11 enables the overdrive system (danger!). When set to 0 all other audio settings have no effect... Additionally, the Path Item, Operation and Example objects, which usually have long descriptions, accept a summary field providing a short description. Documentation generators can use this field in the full list of paths, or in page headers, for example. ",
    "url": "/specification/docs.html#the-description-field",
    
    "relUrl": "/specification/docs.html#the-description-field"
  },"22": {
    "doc": "Providing Documentation and Examples",
    "title": "Providing Long Descriptions in YAML",
    "content": "In JSON format all strings are enclosed in quotes and it is therefore clear where they begin and end. In YAML, though, strings more than one line long can be a bit confusing. To begin with, long descriptions like the one above end when a YAML line is found with smaller indentation. Leading space is important! . Furthermore, the above example uses the plain mode for strings. It is easy to use because it does not require any special syntax, but it can confuse YAML-parsing tools if the string contains colon : or hash # characters. In these cases, the whole string must be enclosed in single or double quotes: . description: \"Beware of lines containing colons and hashes like this: #\" . If precise control over the location of line breaks is required, two more string modes exist, enabled by an indicator character alone on the first line of the description: . | Literal mode (Pipe | indicator character): Line breaks in the source YAML file are preserved in the output. | Folded mode (Greater-than sign &gt; indicator character): Line breaks are removed so the output is a single string. Use an empty line to force a line break. | . YAML source - Literal mode . description: | This is a string in multiple lines. And an extra one. Output - Literal mode . This is a string in multiple lines. And an extra one. YAML source - Folded mode . description: &gt; This is a string in multiple lines. And an extra one. Output - Folded mode . This is a string in multiple lines. And an extra one. The literal and folded modes do not need to use quotes. ",
    "url": "/specification/docs.html#providing-long-descriptions-in-yaml",
    
    "relUrl": "/specification/docs.html#providing-long-descriptions-in-yaml"
  },"23": {
    "doc": "Providing Documentation and Examples",
    "title": "The CommonMark Syntax",
    "content": "description fields allow rich text formatting by using CommonMark 0.27. This section is a quick summary of the syntax of the most commonly used features. Far more features than listed below are available (including HTML tags), but given that OpenAPI descriptions are meant to be included inside larger auto-generated documentation, using more advanced formatting is typically very complicated. Headings . # Level 1 ## Level 2 ### Level 3 . Emphasis . *Emphasis* **Strong Emphasis** ***Both*** . Lists . - Item 1 - Item 2 - Item 2.1 . Code . An inline `code span`. ``` A fenced code block ``` . Links . [Link text](Link URL) ![Alt text](Image URL) . ",
    "url": "/specification/docs.html#the-commonmark-syntax",
    
    "relUrl": "/specification/docs.html#the-commonmark-syntax"
  },"24": {
    "doc": "Providing Documentation and Examples",
    "title": "Adding Examples",
    "content": "Finally, some OpenAPI objects can list examples explicitly instead of having them embedded in the description field, enabling automated processing by tools. This allows, among other things: . | Special rendering of the examples inside the documentation. | Example objects can be used by mock servers as return values. | . Two different fields provide this functionality: example allows one sample whereas examples allows multiple. Only one of the two fields can be present in each object. The content of the example field (found in Parameter, Media Type and Schema Objects) must match the format of its parent object: . schema: coordinate: type: integer minimum: 1 maximum: 3 example: 1 . On the other hand, the examples field (found in Parameter and Media Type Objects) is a map pairing an example name with an Example Object. This object provides a summary and a description for the example along with the actual code (inside the value field or as an external reference in the externalValue field, but not both). This is a snippet from the Tic Tac Toe sample API: . responses: \"400\": description: The provided parameters are incorrect content: text/html: # This is a Media Type Object schema: type: string examples: illegalCoordinates: value: \"Illegal coordinates.\" notEmpty: value: \"Square is not empty.\" invalidMark: value: \"Invalid Mark (X or O).\" . Note how all examples match the schema provided (they are all strings). ",
    "url": "/specification/docs.html#adding-examples",
    
    "relUrl": "/specification/docs.html#adding-examples"
  },"25": {
    "doc": "Providing Documentation and Examples",
    "title": "Summary",
    "content": "This page has shown the features provided by OpenAPI to aid in the documentation process. More specifically: . | Documentation can be added almost everywhere using a description field. Some objects also allow a summary. | Text can use rich formatting using CommonMark syntax, quickly summarized in this page. | Documentation can be extended with sample code using the example or examples fields. | . The next page shows how to specify the server where the API can be accessed. ",
    "url": "/specification/docs.html#summary",
    
    "relUrl": "/specification/docs.html#summary"
  },"26": {
    "doc": "Getting Started",
    "title": "Getting started",
    "content": " ",
    "url": "/#getting-started",
    
    "relUrl": "/#getting-started"
  },"27": {
    "doc": "Getting Started",
    "title": "Intended Audience",
    "content": "This guide is directed at HTTP-based API designers and writers wishing to benefit from having their API formalized in an OpenAPI Description (OAD). Machine-readable API descriptions are ubiquitous nowadays and OpenAPI is the most broadly adopted industry standard for describing new APIs. It is therefore worth learning it and getting it right from the start. These pages are a companion to the OpenAPI Specification (OAS), helping the reader learn it and answering questions like “What is the best way to accomplish… ?” or “What is the purpose of… ?” that are naturally out of the scope of the specification. | If you are unsure if this guide is for you, read the next section below. | If you do not know what “API”, “machine-readable description” or “OpenAPI” mean start by reading the Introduction chapter. | If this is your first time writing an OpenAPI Description read The OpenAPI Specification explained chapter for step-by-step tutorials. | If you already have OpenAPI experience but need help with a specific topic, take a look at the index of The OpenAPI Specification explained chapter; it also includes advanced topics. | Finally, make sure you are aware of the recommended Best Practices to take full advantage of OpenAPI! | And of course, you can always refer to the actual OpenAPI Specification for reference. | . ",
    "url": "/#intended-audience",
    
    "relUrl": "/#intended-audience"
  },"28": {
    "doc": "Getting Started",
    "title": "Advantages of Using OpenAPI",
    "content": "Having your API formally described in a machine-readable format allows automated tools to process it, instantly opening the door to: . | Description Validation and Linting: Check that your description file is syntactically correct and adheres to a specific version of the Specification and the rest of your team’s formatting guidelines. | Data Validation: Check that the data flowing through your API (in both directions) is correct, during development and once deployed. | Documentation Generation: Create traditional human-readable documentation based on the machine-readable description, which always stays up-to-date. | Code Generation: Create both server and client code in any programming language, freeing developers from having to perform data validation or write SDK glue code, for example. | Graphical Editors: Allow easy creation of description files using a GUI instead of typing them by hand. | Mock Servers: Create fake servers providing example responses which you and your customers can start testing with before you write a single line of code. | Security Analysis: Discover possible vulnerabilities at the API design stage instead of much, much later. | . On top of this, the OpenAPI Specification also provides you with: . | A non-proprietary format: You have a say in the future direction of the Specification! | The most developed tooling ecosystem: As a direct result of the previous statement, OpenAPI offers a vast number of tools to work with it. Just take a quick look at OpenAPI Tooling. | A format readable by both machines and humans: Even though writing OADs by hand is not the most convenient way of doing it (See Best Practices), they are plain text files which can be easily browsed in case something needs to be debugged. | . So, choose your desired entry point from the list at the top of this page and start your journey! . ",
    "url": "/#advantages-of-using-openapi",
    
    "relUrl": "/#advantages-of-using-openapi"
  },"29": {
    "doc": "Getting Started",
    "title": "Getting Started",
    "content": " ",
    "url": "/",
    
    "relUrl": "/"
  },"30": {
    "doc": "The OpenAPI Specification Explained",
    "title": "The OpenAPI Specification Explained",
    "content": "The OpenAPI Specification is the ultimate source of knowledge regarding this API description format. However, its length is daunting to newcomers and makes it hard for experienced users to find specific bits of information. This chapter provides a soft landing for readers not yet familiar with OpenAPI and is organized by topic, simplifying browsing. The following pages introduce the syntax and structure of an OpenAPI Description (OAD), its main building blocks and a minimal API description. Afterwards, the different blocks are detailed, starting from the most common and progressing towards advanced ones. | Structure of an OpenAPI Description: JSON, YAML, openapi and info | API Endpoints: paths and responses. | Content of Message Bodies: content and schema. | Parameters and Payload of an Operation: parameters and requestBody. | Reusing Descriptions: components and $ref. | Providing Documentation and Examples: example and examples. | API Servers: servers. | . ",
    "url": "/specification/",
    
    "relUrl": "/specification/"
  },"31": {
    "doc": "Introduction",
    "title": "Introduction",
    "content": "The OpenAPI Specification (OAS) allows the description of a remote API accessible through HTTP or HTTP-like protocols. This description, which may be stored as one or more documents (such as local files or HTTP-accessible network resources), is called an OpenAPI Description (OAD). This chapter explains why describing your API with an OAD is a good thing, and why it might interest you. The concept of an “API” is described first and the advantages of describing APIs using a machine-readable format are introduced, followed by the benefits of using the OAS format. In the last section, the evolution of API descriptions is put into perspective with a brief historical summary. If you are already familiar with the benefits of machine-readable API descriptions and the OpenAPI in particular you may skip ahead to the next chapter, The OpenAPI Specification explained. ",
    "url": "/introduction.html",
    
    "relUrl": "/introduction.html"
  },"32": {
    "doc": "Introduction",
    "title": "What Is an API?",
    "content": "An Application Programming Interface (API) defines the allowed interactions between two pieces of software, just like a User Interface defines the ways in which a user can interact with a program. An API is composed of the list of possible methods to call (requests to make), their parameters, return values and any data format they require (among other things). This is equivalent to how a user’s interactions with a mobile phone app are limited to the buttons, sliders and text boxes in the app’s User Interface. APIs can be local, where both interacting parties run on the same machine. For example, the Windows API offered by the Operating System to its applications, the Standard C Library offered by any C compiler to the programs being compiled, or the TensorFlow API offered by this machine learning library to programs using it. This documentation, though, focuses on remote APIs, where the interacting parties run on separate machines and communicate over a network. For example, a public weather service offering up machine-readable forecasts to be consumed by web pages or mobile applications, or Twitter allowing third-party applications to send messages through its network. To wrap up the definitions, the party offering up its services through an API is called the provider and the one requesting these services is the consumer. Using APIs is an everyday practice in computer science since their benefits are unquestionable. To name only the most prominent: . | APIs provide information hiding: neither side of the API (the provider and the consumer) know the implementation details of the other one. As long as both adhere to the API, they can be changed as much as needed without the other party even noticing. | APIs are also called Contracts, because they are assumed to be unbreakable: The provider promises not to change its API and to keep honoring it in the years to come. With this promise in hand consumers can start developing their parts and rely on the functionality offered up by the API with confidence. | . Now, in order for all involved parties to adhere to the same API it has to be precisely defined. The next section describes how this has traditionally been achieved. ",
    "url": "/introduction.html#what-is-an-api",
    
    "relUrl": "/introduction.html#what-is-an-api"
  },"33": {
    "doc": "Introduction",
    "title": "API Description Through Documentation",
    "content": "APIs are typically accompanied by a reference guide; a piece of literature explaining to a developer how to use the API. Unfortunately, everybody working on software development is familiar with one or more of the following problems: . | Unclear documentation, leading to mistakes due to interpretation differences. | Incomplete or non-existing documentation. | Outdated information. | Information in a language the reader does not understand. | . In these cases, to find the information they require developers might have to read source code (if available), debug programs or analyze network traffic, which are gigantic time sinks. Furthermore, errors in the usage of an API described only through documentation cannot be discovered until runtime, which is another time sink. The next section shows how some of these problems can be alleviated by specifying APIs in a format that automated tools can use. ",
    "url": "/introduction.html#api-description-through-documentation",
    
    "relUrl": "/introduction.html#api-description-through-documentation"
  },"34": {
    "doc": "Introduction",
    "title": "API Description Using the OAS",
    "content": "An API description file (sometimes called contract) is a machine-readable specification of an API. It should strive to be as complete, and fully-detailed as possible, although absolute completeness is not usually a requirement. Also, just like legal contracts, the more unambiguous it is, the more useful it becomes. Its main advantage over documentation which only humans can read is that it enables automated processing, opening the door to the benefits listed at the beginning of this guide. To begin with, documentation for humans including the list of available methods and their details can be easily generated from the API description file. Done as a step in the build process, this easily prevents out-of-sync docs. Furthermore, a tool can use the API description to generate boilerplate code (in any programming language) to build provider and consumer applications. Only the business logic needs to be added and the generated code takes care of all the API handling, removing another source of mistakes and making sure that the code and the documentation match. Additionally, if the data passed to the API must satisfy any constraint it can be automatically verified by the boilerplate code, removing even more manual code. To name only another possibility, the API description file might include examples, and these examples can be used as responses from auto-generated mock servers. This enables early API testing, even before the API provider code is written. For all the above reasons and many more it is highly advisable to use a machine-readable description when designing a new API. Over the years several API description formats (called specifications) emerged. The following section lists the benefits of OpenAPI, the most widely used specification when creating new APIs. ",
    "url": "/introduction.html#api-description-using-the-oas",
    
    "relUrl": "/introduction.html#api-description-using-the-oas"
  },"35": {
    "doc": "Introduction",
    "title": "The OpenAPI Specification",
    "content": "The OpenAPI Specification (OAS) is a vendor-neutral description format for HTTP-based remote APIs. It was originally based on the Swagger 2.0 Specification, donated by SmartBear Software in 2015. Currently, the OAS is maintained, evolved and promoted by the OpenAPI Initiative (OAI), a consortium of industry experts with an open governance structure under the Linux Foundation umbrella. This means all meetings and decisions are public and changes to the OAS can be proposed and discussed by anyone. This openness has encouraged the creation of a vast amount of tools (take a look at the OpenAPI tools list, for example) which perfectly showcase the power of open, machine-readable API descriptions such as OADs. It’s probably because of the amount of tools available when working with OpenAPI that it has become the most broadly adopted industry standard for describing modern APIs. It is also worth mentioning that the OAS does not aim at being able to describe every possible API, since doing so would require a rather large and unwieldy specification. Instead, it tries to describe efficiently the most common use cases. Still, the benefits provided by OpenAPI are so numerous that it is usually worth it to design your API so it can be fully described using the OAS. If parts of your API cannot be described using the OAS, and they cannot be redesigned, they can still be left out of the OAD: OpenAPI lists operations that you can do, but it does not assert anything regarding operations not in the OAD. Finally, OpenAPI can describe APIs based on the HTTP protocol (like RESTful ones) but also APIs based on HTTP-like protocols like CoAP (Constrained Application Protocol) or WebSockets. This allows OpenAPI to be used in resource-restricted scenarios like IoT (Internet of Things), for example. Feel free to jump now to the next chapter, The OpenAPI Specification explained, to start learning how to use the OAS. Or stay a bit longer to gain historical perspective with a comparison of the evolution of local and remote API descriptions. ",
    "url": "/introduction.html#the-openapi-specification",
    
    "relUrl": "/introduction.html#the-openapi-specification"
  },"36": {
    "doc": "Introduction",
    "title": "A Brief Historical Comparison",
    "content": "Machine-readable API descriptions are not a new thing, they have been present in local APIs for a long time: For instance, C has method signatures and higher-level languages like Java or C# have Interface definitions. The remote API descriptions shown in this page serve exactly the same purpose and this section should make it clearer what this purpose is to readers more familiar with traditional local APIs. In the dawn of computer science there existed only the Assembly Language. In this language, to call a method provided by another developer, you write your parameters in some agreed-upon memory address using an agreed-upon format and then you transfer control of the program to another agreed-upon memory address. Eventually control returns to your program and you can retrieve any results from yet another agreed-upon memory address. As you can see, there are a lot of items to agree upon, and all of them must be properly documented. A mistake or misunderstanding in any of these items is undetectable while writing the code, and they lead to runtime issues ranging from program malfunction to system crashes. Fortunately, higher-level languages were created which, among other things, provide method signatures. These signatures are part of the code and are therefore machine-readable, allowing for compile-time detection of mismatches: The API provider publishes the signatures of all its methods and the consumer’s compiler ensures that the API is used correctly (to a greater extent than documentation alone). Later on, the Internet arrived and with it appeared remote APIs. HTTP-based APIs, for instance, request a certain resource from a server and expect the response to contain information in a certain format. Initially all this was specified through documentation and the same problems that existed in the Assembly language resurfaced again, namely, if the request was not made in the format expected by the server things would not work, and errors could not be detected at compile-time. Machine-readable API descriptions (including OpenAPI) were then invented to bring to remote APIs the same degree of robustness that method signatures brought to local APIs. Tools do exist now which check that requests are made in the correct format, or even ensure it by generating the request code themselves. The benefits delivered by machine-readable descriptions of remote APIs, though, have far surpassed those of method signatures. For instance, OpenAPI can attach examples and notes to most API sections, to complement the automatically-generated documentation, or reuse parts of the description to make the whole file leaner. Learn about all these capabilities and more in the next chapter, The OpenAPI Specification explained. ",
    "url": "/introduction.html#a-brief-historical-comparison",
    
    "relUrl": "/introduction.html#a-brief-historical-comparison"
  },"37": {
    "doc": "Parameters and Payload of an Operation",
    "title": "Parameters and Payload of an Operation",
    "content": "The previous page has shown how to describe an operation’s response format, this is, the output data of an operation. On the other hand, this page shows how to specify the input data, this is, the additional information that complements the endpoint and the operation to fully detail a request. OpenAPI provides two mechanisms to specify input data, parameters and request body (message payload). Parameters are typically used to identify a resource, whereas the message payload provides content for that resource. The edges marked with an asterisk are arrays. The Path Item and Operation Objects are explained in the API Endpoints page. The Media Type and Schema Objects are explained in the Content of Message Bodies page. ",
    "url": "/specification/parameters.html",
    
    "relUrl": "/specification/parameters.html"
  },"38": {
    "doc": "Parameters and Payload of an Operation",
    "title": "The Parameter Object",
    "content": "The parameters field in the Path Item and Operation Objects is an array containing Parameter Objects. When provided in the Path Item Object, the parameters are shared by all operations on that path (which can override individual parameters at the Operation Object level but not remove them). Each Parameter Object describes one parameter with the following mandatory fields: . | in (string): Location of the parameter as shown below. | name (string): Case-sensitive. Must be unique in each location. | . Additional optional fields include: . | description (string): Useful for documentation. Might contain usage examples, for instance. | required (boolean): Whether this parameter must be present or not. The default value is false. | . The type of the parameters, their format and their serialization can be specified using additional fields as shown in the next sections. Parameter Location . Parameters can reside in different locations, indicated by the in field. The most common ones are: . | path: The parameter is part of the route of this operation (and hence of its URL). The parameter’s name must appear in the path as a template expression, i.e., delimited by curly braces {}. For example, the path /users/{id} must contain at least one parameter described with: . paths: /users/{id}: get: parameters: - name: id in: path required: true . NOTE: When using path parameters, the required field must be present and it must be true. | query: The parameter is appended to the query string part of the operation’s URL. For example, the URL /users?id=1234 can be parsed using: . paths: /users: get: parameters: - name: id in: query . | header: The parameter is sent in a custom HTTP header as part of the request. Header names are case-insensitive. | . Parameter Type . Most of the time a parameter’s type can be specified by using a Schema Object in the schema field. Schema objects allow defining primitive or complex types (like arrays or objects) and impose additional restrictions on them. For example: . parameters: - name: id in: query schema: type: integer minimum: 1 maximum: 100 . The Content of Message Bodies page describes Schema objects in greater detail. In more advanced scenarios the content field can be used instead. It provides a single-entry map of Media Types to Media Type Objects (More details can be found in the Content of Message Bodies page). NOTE: Exactly one of schema or content must be present. They cannot appear at the same time. Parameter Serialization Control . The style field describes how a parameter is to be serialized and its effect depends on the type of the parameter. The resulting matrix is therefore rather complex and can be consulted in the Parameter Object specification page. The tables given below exemplify the most common styles simple, form, label, and matrix: . | Primitive types: For example, an integer named id with value 1234. | style: | simple | form | label | matrix | . |   | 1234 | id=1234 | .1234 | ;id=1234 | . | Array types: For example, an array named ids containing the integers 1, 2 and 3. The explode field can be used to separate each element of the array into a separate parameter. | style: | simple | form | label | matrix | . | with explode=false | 1,2,3 | ids=1,2,3 | .1.2.3 | ;ids=1,2,3 | . | with explode=true | 1,2,3 | ids=1&amp;ids=2&amp;ids=3 | .1.2.3 | ;ids=1;ids=2;ids=3 | . | Object types: For example, an object named color containing integer fields R, G and B with values 1, 2 and 3. Again, explode can be used to separate each field into a separate parameter. | style: | simple | form | label | matrix | . | with explode=false | R,1,G,2,B,3 | color=R,1,G,2,B,3 | .R.1.G.2.B.3 | ;color=R,1,G,2,B,3 | . | with explode=true | R=1,G=2,B=3 | R=1&amp;G=2&amp;B=3 | .R=1.G=2.B=3 | ;R=1;G=2;B=3 | . | . For more serialization options see the Parameter Object specification. ",
    "url": "/specification/parameters.html#the-parameter-object",
    
    "relUrl": "/specification/parameters.html#the-parameter-object"
  },"39": {
    "doc": "Parameters and Payload of an Operation",
    "title": "The Request Body Object",
    "content": "When updating a record on a database, the parameters are typically used to identify the record whereas the message body provides its new content. The message body of a request is specified through the requestBody field in the Operation Object, which is a Request Body Object. paths: /board: put: requestBody: ... The only mandatory field in the Request Body Object is content which is described in detail in the Content of Message Bodies page. As a reminder, the snippet below describes an operation with a JSON request body containing a single integer with values between 1 and 100. requestBody: content: application/json: schema: type: integer minimum: 1 maximum: 100 . The Request Body Object also has a description string and a required boolean to state whether the message payload is mandatory. ",
    "url": "/specification/parameters.html#the-request-body-object",
    
    "relUrl": "/specification/parameters.html#the-request-body-object"
  },"40": {
    "doc": "Parameters and Payload of an Operation",
    "title": "Tic Tac Toe Example",
    "content": "The Tic Tac Toe sample API contains two endpoints, one without parameters or request body (/board) and another one with both (/board/{row}/{column}). The relevant code snippet for the second endpoint is shown below and it should be easy to understand after reading this page. paths: # Single square operations /board/{row}/{column}: parameters: - name: row in: path required: true schema: type: integer minimum: 1 maximum: 3 - name: column in: path required: true schema: type: integer minimum: 1 maximum: 3 get: summary: Get a single board square responses: ... put: summary: Set a single board square requestBody: required: true content: application/json: schema: type: string enum: [\".\", \"X\", \"O\"] responses: ... | Both operations (get and put) have the same parameters, since they are described at the Path Item level. | The parameters are two integers, named row and column which are located in the path of the operation. This matches the path name which contains {row} and {column}. | The put operation, additionally, must provide a request body which must be one of the three provided strings: ., X and O. | . The complete Tic Tac Toe sample API does not look exactly like the above snippet because it reuses portions of the description to remove redundancy. This technique is explained in the Reusing Descriptions page. ",
    "url": "/specification/parameters.html#tic-tac-toe-example",
    
    "relUrl": "/specification/parameters.html#tic-tac-toe-example"
  },"41": {
    "doc": "Parameters and Payload of an Operation",
    "title": "Summary",
    "content": "This page has shown: . | How to specify the two types of input data an operation can provide: parameters and requestBody. | Parameters can be located in different places (path, query, headers) and their content (schema) and serialization (style) is highly customizable. | The request body is specified, much like responses are, using the content field. | . The next page explains how to reuse portions of an OpenAPI Description to remove redundancy, reducing file size and maintenance cost. ",
    "url": "/specification/parameters.html#summary",
    
    "relUrl": "/specification/parameters.html#summary"
  },"42": {
    "doc": "API Endpoints",
    "title": "API Endpoints",
    "content": "The previous page showed the minimal structure of an OpenAPI Description (OAD) but did not add any operation to the API. This page explains how to do it. ",
    "url": "/specification/paths.html",
    
    "relUrl": "/specification/paths.html"
  },"43": {
    "doc": "API Endpoints",
    "title": "The Endpoints list",
    "content": "API Endpoints (also called Operations or Routes) are called Paths in the OAS. The Paths Object, accessible through the paths field in the root OpenAPI Object, is the container for all operations supported by the API: . The OpenAPI Object is explained in the Structure of an OpenAPI Description page. Every field in the Paths Object is a Path Item Object describing one API endpoint. Fields are used instead of an Array because they enforce endpoint name uniqueness at the syntax level (any JSON or YAML parser can detect mistakes without requiring an OpenAPI validator). Paths must start with a forward slash / since they are directly appended to the server URL (described in the API Servers page) to construct the full endpoint URL. The Tic Tac Toe sample API is used in this guide to exemplify each concept and it is built piece by piece as the guide progresses. Here’s the first snippet already containing a single endpoint: . openapi: 3.1.0 info: title: Tic Tac Toe description: | This API allows writing down marks on a Tic Tac Toe board and requesting the state of the board or of individual squares. version: 1.0.0 paths: /board: ... ",
    "url": "/specification/paths.html#the-endpoints-list",
    
    "relUrl": "/specification/paths.html#the-endpoints-list"
  },"44": {
    "doc": "API Endpoints",
    "title": "The Path Item Object",
    "content": "The Path Item Object describes the HTTP operations that can be performed on a path with a separate Operation Object for each one. Allowed operations match HTTP method names like get, put or delete, to list the most common (find the complete list in the Path Item Object specification). This object also accepts common properties for all operations on the path like summary or description. The details of each operation are given in each child Operation object. paths: /board: get: ... put: ... ",
    "url": "/specification/paths.html#the-path-item-object",
    
    "relUrl": "/specification/paths.html#the-path-item-object"
  },"45": {
    "doc": "API Endpoints",
    "title": "The Operation Object",
    "content": "Besides giving the operation a summary and a description, the Operation Object basically describes the operation’s parameters, payload and possible server responses. The rest of this page explains the responses field, whereas parameters and payload are dealt with in another page. paths: /board: get: summary: Get the whole board description: Retrieves the current state of the board and the winner. parameters: ... responses: ... ",
    "url": "/specification/paths.html#the-operation-object",
    
    "relUrl": "/specification/paths.html#the-operation-object"
  },"46": {
    "doc": "API Endpoints",
    "title": "The Responses Object",
    "content": "The Responses Object is a container for the expected answers the server can give to this request. Each field name is an HTTP response code enclosed in quotation marks and its value is a Response Object (note there is no ‘s’ at the end) containing details about the response. At least one response must be given and it is recommended that it corresponds to the success case (typically HTTP response code 200). 5 wildcards are allowed: 1XX, 2XX, 3XX, 4XX and 5XX (explicit codes take preference over wildcards). paths: /board: get: responses: \"200\": ... \"404\": ... ",
    "url": "/specification/paths.html#the-responses-object",
    
    "relUrl": "/specification/paths.html#the-responses-object"
  },"47": {
    "doc": "API Endpoints",
    "title": "The Response Object",
    "content": "The Response Object contains a mandatory description of the meaning of the response in the context of this operation, complementing the sense of the HTTP response codes (which are generic in nature). This helps developers understand better how to react to this particular code. The most important field, though, is content because it describes the possible payloads of the response. Due to its complexity, this field’s format is detailed next, in its own page. paths: /board: get: responses: \"200\": description: Everything went fine. content: ... ",
    "url": "/specification/paths.html#the-response-object",
    
    "relUrl": "/specification/paths.html#the-response-object"
  },"48": {
    "doc": "API Endpoints",
    "title": "Tic Tac Toe Example",
    "content": "Here’s a fragment of the example, containing only the objects that have been described so far in the guide. At this point the reader should be able to understand every line of this snippet. openapi: 3.1.0 info: title: Tic Tac Toe description: | This API allows writing down marks on a Tic Tac Toe board and requesting the state of the board or of individual squares. version: 1.0.0 paths: # Whole board operations /board: get: summary: Get the whole board description: Retrieves the current state of the board and the winner. responses: \"200\": description: \"OK\" content: ... The complete OpenAPI Description can be found in the Tic Tac Toe sample API. ",
    "url": "/specification/paths.html#tic-tac-toe-example",
    
    "relUrl": "/specification/paths.html#tic-tac-toe-example"
  },"49": {
    "doc": "API Endpoints",
    "title": "Summary",
    "content": "This page has shown how to specify endpoints (paths), their available operations (get, put, …) and their possible outcomes (responses). The next page shows how to specify the content of the responses. ",
    "url": "/specification/paths.html#summary",
    
    "relUrl": "/specification/paths.html#summary"
  },"50": {
    "doc": "Describing API Security",
    "title": "Describing API Security",
    "content": "One feature of OpenAPI that can prove useful to API providers and consumers is the means to describe API security. Providing information about the security that protects a given API and its Operations is useful to humans, as they can understand security restrictions and account for them in their implementation, and for tooling that can generate code or provide features that facilitate submitting authorization parameters. OpenAPI provides the Security Scheme Object, which contains security definitions that can be referenced either globally or per Operation. Unlike other Component objects, Security Scheme objects are referenced by name using a Security Requirement Object. A security description for a given API or Operation therefore must be defined as a Security Scheme Object as they cannot be declared inline. Security Scheme objects are referenced as Security Requirements, either globally or by an Operation. A Security Requirement declared for a given Operation takes precedence over global Security Requirements. A number of security mechanisms are supported. Each mechanism is indicated using the type property, which is shown in the examples below. There is currently five supported security types, namely: . | API Keys | HTTP Authentication | Mutual TLS | OAuth 2.0 | OpenID Connect | . Each is discussed in the sections below. ",
    "url": "/specification/security.html",
    
    "relUrl": "/specification/security.html"
  },"51": {
    "doc": "Describing API Security",
    "title": "API Keys",
    "content": "An API key is - generally speaking - the API equivalent of a password and is used to supply a secret known only by a given API consumer and the API provider. There are no formal standards that govern API keys and the industry generally relies on accepted best practices for their definition. OpenAPI therefore provides flexibility in how they are defined. For example, an API provider might use the HTTP header api-key as the means for API consumers to send their API keys with each request. A Security Scheme object can be defined to indicate in which HTTP header the API Key should be sent: . components: securitySchemes: defaultApiKey: description: API key provided in console type: apiKey name: api-key in: header . The API provider can then use the name of this Scheme Scheme object to apply security either globally or for a given Operation (both are shown below for the sake of exemplar): . openapi: 3.1.0 info: title: Tic Tac Toe description: | This API allows writing down marks on a Tic Tac Toe board and requesting the state of the board or of individual squares. version: 1.0.0 security: defaultApiKey: [] paths: /board: get: security: defaultApiKey: [] . This method of referencing Security Scheme objects is valid for all types. The array shown as the value of defaultApiKey above is populated for OAuth Flow and OpenID Connect objects, which have some additional features that are discussed below. In all other cases an empty array is provided. ",
    "url": "/specification/security.html#api-keys",
    
    "relUrl": "/specification/security.html#api-keys"
  },"52": {
    "doc": "Describing API Security",
    "title": "HTTP Authentication",
    "content": "OpenAPI supports HTTP Authentication as defined in RFC7235, which implements the Authorization header as the means to send both the authorization scheme identifier and the parameter in the format Authorization: Basic b3BlbmFwaTppc2dyZWF0. The authorization scheme should be defined in the IANA registry for HTTP Authentication, but API providers can extend this to use custom values if required. The example below shows a Security Scheme object that specifies both Basic Authentication and Bearer tokens. The Bearer token example includes an additional hint, the bearerFormat property, that gives the API consumer additional information on format of the token (in this case a JSON Web Token or JWT). components: securitySchemes: basicHttpAuthentication: description: Basic HTTP Authentication type: http scheme: Basic bearerHttpAuthentication: description: Bearer token using a JWT type: http scheme: Bearer bearerFormat: JWT . You’ll note that in both cases the information provided is relatively terse. OpenAPI provides enough information to give humans and tooling the means to understand the basic security requirements, but deployment information such as onboarding or key exchange is out-of-scope. ",
    "url": "/specification/security.html#http-authentication",
    
    "relUrl": "/specification/security.html#http-authentication"
  },"53": {
    "doc": "Describing API Security",
    "title": "Mutual TLS",
    "content": "Mutual authentication over TLS (mTLS) is a very common API security approach in verticals such as financial services. This is due to its enhanced security posture through authentication of the HTTP Client at the transport layer. Defining mTLS in OpenAPI is very simple: . type: mutualTLS . As before the information provided is terse. Establishing the private key infrastructure used to govern communications between the API provider and consumer, together with the associated deployment information such as certificate signing and so on, is beyond the scope of OpenAPI. ",
    "url": "/specification/security.html#mutual-tls",
    
    "relUrl": "/specification/security.html#mutual-tls"
  },"54": {
    "doc": "Describing API Security",
    "title": "OAuth 2.0",
    "content": "OAuth 2.0 is a very popular authorization framework in the API world due to its support for delegated access without giving up End Users credentials to an untrusted application. It is described using a specific object, namely the OAuth Flows Object. This object is provided due to the relative complexity of the protocol compared to other security types, with different grant types representing different mechanisms for obtaining authorization to access protected resources. The OAuth Flows Object has properties representing the different OAuth 2.0 grant types, each of which references the OAuth Flow Object. The OAuth Flow Object properties describe the Authorization Server URL, Token Endpoint and optionally the permitted OAuth scopes. The example below shows the properties for the Client Credentials and Authorization Code grant types: . components: securitySchemes: oauth2Profiles: type: oauth2 flows: clientCredentials: tokenUrl: https://learn.openapis.org/oauth/2.0/token scopes: board:read: Read the board board:write: Write to the board authorizationCode: authorizationUrl: https://learn.openapis.org/oauth/2.0/auth tokenUrl: https://learn.openapis.org/oauth/2.0/token scopes: board:read: Read the board board:write: Write to the board . These can then be applied globally or for a given Operation, with a list of required scopes: . openapi: 3.1.0 info: title: Tic Tac Toe description: | This API allows writing down marks on a Tic Tac Toe board and requesting the state of the board or of individual squares. version: 1.0.0 security: oauth2Profiles: - board:read - board:write paths: /board: get: security: oauth2Profiles: [] . Note that if you want to segregate grant types - where, for example, Client Credentials is only supported for a specific Operation - you’ll need to create a separate Security Scheme object that can be applied individually. This is also true if you want to differentiate the available scopes, for example: . components: securitySchemes: app2AppOauth: type: oauth2 flows: clientCredentials: tokenUrl: https://learn.openapis.org/oauth/2.0/token # Only reading the board allow with delegated access board:read: Read the board user2AppOauth: authorizationCode: authorizationUrl: https://learn.openapis.org/oauth/2.0/auth tokenUrl: https://learn.openapis.org/oauth/2.0/token scopes: # Reads and writes permitted via authorization code flow board:read: Read the board board:write: Write to the board . These then be declared as separate Security Requirements: . info: title: Tic Tac Toe description: | This API allows writing down marks on a Tic Tac Toe board and requesting the state of the board or of individual squares. version: 1.0.0 paths: /board: get: security: app2AppOauth: - board:read ... /board/{row}/{column}: put: security: user2AppOauth: - board:read - board:write ... Please refer to our example OpenAPI document for the complete example. ",
    "url": "/specification/security.html#oauth-20",
    
    "relUrl": "/specification/security.html#oauth-20"
  },"55": {
    "doc": "Describing API Security",
    "title": "OpenID Connect",
    "content": "The final Security Scheme type is OpenID Connect, which provides information for OpenID Connect Discovery. OpenID Connect Core is obviously an OAuth 2.0 profile and is supported by some of properties the OAuth Flow Object. However, OpenID Connect is generally more complex than plain OAuth 2.0 and given OpenID Connect Discovery provides a machine-readable format at the discovery endpoint it makes sense to outsource this functionality entirely. Specifying OpenID Connect is therefore straightforward in that you provide the discovery endpoint in the property openIdConnectUrl: . components: securitySchemes: openIdConnect: type: openIdConnect openIdConnectUrl: https://learn.openapis.org/.well-known/openid-configuration . The neat trick here is that you do not need to declare scopes in your OpenAPI document. You can specify scopes in your discovery endpoint, and then use them in your OpenAPI document with the expectation that compatible tooling will have parsed and read them: . openapi: 3.1.0 info: title: Tic Tac Toe description: | This API allows writing down marks on a Tic Tac Toe board and requesting the state of the board or of individual squares. version: 1.0.0 security: openIdConnect: - board:read - board:write . This approach allows OpenAPI to provide just enough information for humans and tooling, whilst ensuring that OpenID Connect Discovery provides the system-or-record for security-related information. ",
    "url": "/specification/security.html#openid-connect",
    
    "relUrl": "/specification/security.html#openid-connect"
  },"56": {
    "doc": "Describing API Security",
    "title": "Summary",
    "content": "In this page we’ve learnt that: . | API security can be described in OpenAPI. | Security properties must be described using a Security Scheme object. | A Security Scheme object is referenced either globally or for a given Operation using a Security Requirement. | OpenAPI supports a number of built-in security types, with different properties dependent on the type. | . ",
    "url": "/specification/security.html#summary",
    
    "relUrl": "/specification/security.html#summary"
  },"57": {
    "doc": "API Servers",
    "title": "API Servers",
    "content": "This page shows how to specify the server where the API can be accessed, which can contain multiple URLs and even variable portions. ",
    "url": "/specification/servers.html",
    
    "relUrl": "/specification/servers.html"
  },"58": {
    "doc": "API Servers",
    "title": "The Server Object",
    "content": "The Server Object provides the base URLs where the API is being served. It can be found in the servers array present in the root OpenAPI Object, the Path Item Object and the Operation Object. The edges marked with an asterisk are arrays.The OpenAPI Object is explained in the Structure of an OpenAPI Description page.The Paths, Path Item and Operation Objects are explained in the API Endpoints page. Each element in a servers array is a Server Object providing, at least, a url field with the base URL for that server. An optional description aids in keeping server lists organized: . servers: - url: https://europe.server.com/v1 description: Server located in Germany. - url: https://america.server.com/v1 description: Server located in Atlanta, GA. - url: https://asia.server.com/v1 description: Server located in Shenzhen . Individual API endpoints (as specified in the Paths Object) are then appended to this URL to construct the full endpoint URL. For example: . servers: - url: https://server.com/v1 paths: /users: get: . The above operation can be accessed by executing a GET request on the URL https://server.com/v1/users. When multiple servers arrays are specified at different levels for a given operation, only the lowest level one is taken into account. For example, in this case: . servers: - url: https://server1.com paths: /users: get: servers: - url: https://server2.com . GET requests to the /users endpoint are served from https://server2.com and not from https://server1.com. NOTE: When providing multiple servers in an OpenAPI Description (OAD) keep in mind that they should all provide the same API (since they are being listed in the same API description). If the servers are used for different environments (for example Testing and Production), chances are that their APIs will be different and describing them in a single OAD will be complicated. In these cases it is probably better to use different OADs, and even different API versions. Read the Reusing Descriptions page to learn how to avoid code duplication and maintenance costs in these scenarios. Conversely, if no servers are provided, it is assumed that all API endpoints are relative to the location where the OpenAPI Description document is being served. Be aware that if your OAD is split across multiple documents, each endpoint id assumed to be relative to the document in which it is described. Describing a server ensures that your endpoints are the same regardless of how your OAD is organized. Finally, the server URLs can contain variable portions, as shown next. ",
    "url": "/specification/servers.html#the-server-object",
    
    "relUrl": "/specification/servers.html#the-server-object"
  },"59": {
    "doc": "API Servers",
    "title": "Server Variables",
    "content": "Server URLs can contain variables, delimited by curly braces {}: . servers: - url: https://{username}.server.com:{port}/{version} . These variables must then be further detailed in the variables field. This field is a map pairing variable names (matching the ones in curly braces in the server’s url) and Server Variable Objects. The Server Variable Object has the following fields: . | default (string): This is a mandatory field and it is the value that should be used if there is no other value to provide. | enum (array of strings): If present, this array lists the valid values for the variable (and the default value must be in the array). | description (string): Documentation always helps understand the purpose of a variable. | . Therefore, the above example could be extended like this: . servers: - url: https://{username}.server.com:{port}/{version} variables: username: default: demo description: This value is assigned by the service provider. port: enum: - \"8443\" - \"443\" default: \"8443\" version: default: v1 . NOTE: The default variable value works differently than the default Schema Object value used in other parts of the OpenAPI Specification. The latter is optional, meaning that if a Schema Object value is not provided it should be assumed to be the default value. On the other hand, server variables must always be provided. ",
    "url": "/specification/servers.html#server-variables",
    
    "relUrl": "/specification/servers.html#server-variables"
  },"60": {
    "doc": "API Servers",
    "title": "Summary",
    "content": "This page has shown that: . | Server lists can be provided through the servers array. | This array is present at different levels (OpenAPI Object, Path Item Object and Operation Object) and only the innermost one is used. | Server URLs can contain variables for further customization like https://{username}.server.com:{port}/{version} | . ",
    "url": "/specification/servers.html#summary",
    
    "relUrl": "/specification/servers.html#summary"
  },"61": {
    "doc": "Structure of an OpenAPI Description",
    "title": "Structure of an OpenAPI Description",
    "content": "An OpenAPI Description (OAD) describes an HTTP-like API in one or more machine-readable documents (files or network resources). This page describes the syntax of these documents and the minimal structure they must contain. ",
    "url": "/specification/structure.html",
    
    "relUrl": "/specification/structure.html"
  },"62": {
    "doc": "Structure of an OpenAPI Description",
    "title": "OpenAPI Description Syntax",
    "content": "OpenAPI Descriptions are written as one or more text documents. Each document represents a JSON object, in either JSON or YAML format. References are used to link parts of the JSON object(s) to each other, and this linked structure is the complete OpenAPI Description. Parsing begins with an OpenAPI Object, and the document containing that object is known as the entry document, commonly called openapi.json or openapi.yaml. This section very briefly describes and compares the JSON and YAML data formats. JSON can represent Numbers, Strings, Booleans, null values, Arrays and Objects. An array is an ordered list of values which can have different types. An object (also called a Map) is a collection of name-value pairs where the names (also called Keys or Fields) are unique within the object and the values can have any of the supported types (including other objects or arrays). Here’s a comparison showing the different syntaxes. JSON: . { \"anObject\": { \"aNumber\": 42, \"aString\": \"This is a string\", \"aBoolean\": true, \"nothing\": null, \"arrayOfNumbers\": [ 1, 2, 3 ] } } . YAML: . # Anything after a hash sign is a comment anObject: aNumber: 42 aString: This is a string aBoolean: true nothing: null arrayOfNumbers: - 1 - 2 - 3 . Basically, JSON does not support comments and requires: commas separating fields, curly brackets around objects, double quotation marks around strings and square brackets around arrays. On the other hand, YAML requires hyphens before array items and relies heavily on indentation, which can be cumbersome on large files (indentation is entirely optional in JSON). YAML is typically preferred because of its slightly reduced file size, but the two formats are completely interchangeable (as long as YAML 1.2 is used). All examples in these pages will be given in YAML. However, YAML being a superset of JSON means that both syntaxes can be mixed. While this is not recommended in general, it can come in handy sometimes. For example: . anObject: aString: This is a string arrayOfNumbers: [ 1, 2, 3 ] # Abbreviated array representation . Finally, object field names are case-sensitive: openapi is not the same thing as OpenAPI. NOTE: Ellipses (…) are used throughout this guide to indicate an incomplete code snippet. Ellipses are not part of JSON or YAML. ",
    "url": "/specification/structure.html#openapi-description-syntax",
    
    "relUrl": "/specification/structure.html#openapi-description-syntax"
  },"63": {
    "doc": "Structure of an OpenAPI Description",
    "title": "Minimal OpenAPI Description Structure",
    "content": "To be entirely precise, a minimal OpenAPI Description (OAD) is a single JSON object containing fields adhering to the structure defined in the OpenAPI Specification (OAS). The OAS structure is long and complex so this section just describes the minimal set of fields it must contain, while following pages give more details about specific objects. The OpenAPI Map is a nice visual tool that can help familiarize the reader with this long specification. The root object in any OpenAPI Description is the OpenAPI Object, and only two of its fields are mandatory: openapi and info. Additionally, at least one of paths, components and webhooks is required. | openapi (string): This indicates the version of the OAS this OAD is using, e.g. “3.1.0”. Using this field tools can check that the description correctly adheres to the specification. | info (Info Object): This provides general information about the API (like its description, author and contact information) but the only mandatory fields are title and version. | title (string): A human-readable name for the API, like “GitHub REST API”, useful to keep API collections organized. | version (string): Indicates the version of the API description (not to be confused with the OAS version above). Tools can use this field to generate code that ensures that clients and servers are interacting through the same version of the API, for example. | . | paths (Paths Object): This describes all the endpoints of the API, including their parameters and all possible server responses. Server and client code can be generated from this description, along with its documentation. | . Diagrams are used in this guide to show the relationship between the different objects. Here’s an example of a minimal OpenAPI Description: . openapi: 3.1.0 info: title: A minimal OpenAPI Description version: 0.0.1 paths: {} # No endpoints defined . This API is not very useful because it defines no operations (it has no endpoints). The next page remedies that. ",
    "url": "/specification/structure.html#minimal-openapi-description-structure",
    
    "relUrl": "/specification/structure.html#minimal-openapi-description-structure"
  },"64": {
    "doc": "Structure of an OpenAPI Description",
    "title": "Summary",
    "content": "This page has shown that: . | The syntax (language) used to write OpenAPI Descriptions can be JSON, YAML or both. | An OpenAPI Description is a JSON object including the fields described in the OpenAPI Specification. | Every OpenAPI Descriptions must contain an OpenAPI Object with at least the fields openapi, and info, and either paths, components or webhooks. | . The following page describes the contents of the paths field so endpoints can be added to the above minimal snippet. ",
    "url": "/specification/structure.html#summary",
    
    "relUrl": "/specification/structure.html#summary"
  }
}
